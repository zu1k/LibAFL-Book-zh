<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>简单的模糊器实例 - LibAFL模糊测试库</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="libafl.html">LibAFL模糊测试库</a></li><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="getting_started/getting_started.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/setup.html"><strong aria-hidden="true">1.1.</strong> 设置</a></li><li class="chapter-item expanded "><a href="getting_started/build.html"><strong aria-hidden="true">1.2.</strong> 构建</a></li><li class="chapter-item expanded "><a href="getting_started/crates.html"><strong aria-hidden="true">1.3.</strong> Crates</a></li></ol></li><li class="chapter-item expanded "><a href="baby_fuzzer.html" class="active"><strong aria-hidden="true">2.</strong> 简单的模糊器实例</a></li><li class="chapter-item expanded "><a href="core_concepts/core_concepts.html"><strong aria-hidden="true">3.</strong> 核心概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_concepts/observer.html"><strong aria-hidden="true">3.1.</strong> 观察者 Observer</a></li><li class="chapter-item expanded "><a href="core_concepts/executor.html"><strong aria-hidden="true">3.2.</strong> 执行器 Executor</a></li><li class="chapter-item expanded "><a href="core_concepts/feedback.html"><strong aria-hidden="true">3.3.</strong> 反馈 Feedback</a></li><li class="chapter-item expanded "><a href="core_concepts/input.html"><strong aria-hidden="true">3.4.</strong> 输入 Input</a></li><li class="chapter-item expanded "><a href="core_concepts/corpus.html"><strong aria-hidden="true">3.5.</strong> 语料库 Corpus</a></li><li class="chapter-item expanded "><a href="core_concepts/mutator.html"><strong aria-hidden="true">3.6.</strong> 突变器 Mutator</a></li><li class="chapter-item expanded "><a href="core_concepts/generator.html"><strong aria-hidden="true">3.7.</strong> 生成器 Generator</a></li><li class="chapter-item expanded "><a href="core_concepts/stage.html"><strong aria-hidden="true">3.8.</strong> 阶段 Stage</a></li></ol></li><li class="chapter-item expanded "><a href="design/design.html"><strong aria-hidden="true">4.</strong> 设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/architecture.html"><strong aria-hidden="true">4.1.</strong> 架构</a></li><li class="chapter-item expanded "><a href="design/metadata.html"><strong aria-hidden="true">4.2.</strong> 元数据</a></li></ol></li><li class="chapter-item expanded "><a href="message_passing/message_passing.html"><strong aria-hidden="true">5.</strong> 消息传递</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message_passing/spawn_instances.html"><strong aria-hidden="true">5.1.</strong> 生成实例</a></li><li class="chapter-item expanded "><a href="message_passing/configurations.html"><strong aria-hidden="true">5.2.</strong> 配置</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/tutorial.html"><strong aria-hidden="true">6.</strong> 教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/intro.html"><strong aria-hidden="true">6.1.</strong> 简介</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_features/advanced_features.html"><strong aria-hidden="true">7.</strong> 高级功能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_features/concolic/concolic.html"><strong aria-hidden="true">7.1.</strong> 同心追踪和混合模糊</a></li><li class="chapter-item expanded "><a href="advanced_features/no_std/no_std.html"><strong aria-hidden="true">7.2.</strong> LibAFL在 no_std 环境下 (内核、管理程序...) </a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LibAFL模糊测试库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="一个简单的libafl模糊器"><a class="header" href="#一个简单的libafl模糊器">一个简单的LibAFL模糊器</a></h1>
<p>本章讨论了一个使用 LibAFL API 构建的极其简单的模糊器。
你将学习基本的实体，如 <code>State</code>、<code>Observer</code> 和 <code>Executor</code>。
虽然下面的章节会详细讨论 LibAFL 的组件，但在这里我们介绍基本原理。</p>
<p>我们将对一个简单的 Rust 函数进行模糊处理，该函数在某个条件下会出现panic。这个模糊器将是单线程的，并在崩溃后停止，就像libFuzzer通常做的那样。</p>
<p>你可以在 <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/baby_fuzzer"><code>fuzzers/baby_fuzzer</code></a> 中找到本教程的完整版本，作为一个模糊器的例子。</p>
<blockquote>
<h3 id="警告"><a class="header" href="#警告">警告</a></h3>
<p>这个示例模糊器对于任何现实世界的使用来说都是太天真了。
它的目的仅仅是为了展示库的主要组件，如果想更深入地了解如何构建一个自定义的模糊器，请直接阅读 <a href="./tutorial/intro.html">Tutorial chapter</a>。</p>
</blockquote>
<h2 id="创建一个项目"><a class="header" href="#创建一个项目">创建一个项目</a></h2>
<p>我们使用 <code>cargo</code> 创建一个新的Rust项目，将 <code>LibAFL</code> 作为一个依赖项。</p>
<pre><code class="language-sh">$ cargo new baby_fuzzer
$ cd baby_fuzzer
</code></pre>
<p>生成的 <code>Cargo.toml</code> 看起来像下面这样: </p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>为了使用 LibAFl，我们必须在 <code>[dependencies]</code> 下增添其依赖 <code>libafl = { path = &quot;path/to/libafl/&quot; }</code>。
如果你愿意，你可以使用 crates.io 的 LibAFL 版本，在这种情况下，你必须使用 <code>libafl = &quot;*&quot;</code> 来获取最新的版本 (或者将其设置为当前版本) 。</p>
<p>由于我们要对Rust代码进行模糊处理，我们希望崩溃不会简单地导致程序退出，而是引发一个 <code>abort</code> ，然后可以被模糊器捕获。
为此，我们在 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">profiles</a> 中指定 <code>panic = &quot;abort&quot;</code>。</p>
<p>除了这个设置之外，我们还为在发布模式下的编译添加了一些优化标志，最终的 <code>Cargo.toml</code> 应该类似于下面的样子: </p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
libafl = { path = &quot;path/to/libafl/&quot; }

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
lto = true
codegen-units = 1
opt-level = 3
debug = true
</code></pre>
<h2 id="被测试的函数"><a class="header" href="#被测试的函数">被测试的函数</a></h2>
<p>打开 <code>src/main.rs</code>，我们有一个空的 <code>main</code> 函数。
首先，我们创建一个我们想要模糊处理的闭包。它接受一个缓冲区作为输入，如果它以 <code>abc</code> 开头，就会引起崩溃: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libafl;
use libafl::inputs::{BytesInput, HasTargetBytes};

let mut harness = |input: &amp;BytesInput| {
    let target = input.target_bytes();
    let buf = target.as_slice();
    if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
        if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
            if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                panic!(&quot;=)&quot;);
            }
        }
    }
};
// To test the panic:
// let input = BytesInput::new(&quot;abc&quot;.as_bytes());
// harness(&amp;input);
<span class="boring">}
</span></code></pre></pre>
<h2 id="生成和运行一些测试"><a class="header" href="#生成和运行一些测试">生成和运行一些测试</a></h2>
<p>基于 LibAFL 的模糊测试器使用的主要组件之一是状态，这是一个在模糊测试过程中演变的数据容器。
包括所有的状态，如输入的语料库，当前的rng状态，以及测试案例和运行的潜在 Metadata。
在我们的 <code>main</code> 中，我们创建了一个基本的 State 实例，如下所示。</p>
<pre><code class="language-rust ignore">// create a State from scratch
let mut state = StdState::new(
    // RNG
    StdRand::with_seed(current_nanos()),
    // Corpus that will be evolved, we keep it in memory for performance
    InMemoryCorpus::new(),
    // Corpus in which we store solutions (crashes in this example),
    // on disk so the user can get them after stopping the fuzzer
    OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
    (),
);
</code></pre>
<p>它需要一个随机数发生器，这是模糊器状态的一部分，在这种情况下，我们使用默认的 <code>StdRand</code> ，但你可以选择一个不同的。我们用当前的纳秒数作为种子。</p>
<p>作为第二个参数，它需要一个实现语料库特性的实例，本例中是 <code>InMemoryCorpus</code>。语料库是由模糊器演化出的测试案例的容器，在这种情况下，我们把它全部放在内存中。</p>
<p>我们将在后面讨论最后一个参数。第三个参数是另一个语料库，在这种情况下，用来存储被视为模糊器 &quot;solutions&quot; 的测试案例。对于我们的目的，solutions是触发崩溃的输入。在这种情况下，我们想把它存储在磁盘的 <code>crashes</code> 目录下，这样我们就可以检查它。</p>
<p>另一个必要的组件是 <code>EventManager</code>。它处理一些事件，如在模糊处理过程中向语料库添加测试案例。对于我们的目的，我们使用最简单的一个，它只是用一个 <code>Monitor</code> 实例向用户显示这些事件的信息。</p>
<pre><code class="language-rust ignore">// The Monitor trait defines how the fuzzer stats are displayed to the user
let mon = SimpleMonitor::new(|s| println!(&quot;{}&quot;, s));

// The event manager handle the various events generated during the fuzzing loop
// such as the notification of the addition of a new item to the corpus
let mut mgr = SimpleEventManager::new(mon);
</code></pre>
<p>此外，我们还有 Fuzzer，一个包含一些改变状态的行动的实体。其中一个动作是使用 <code>CorpusScheduler</code> 为模糊器调度测试案例。
我们将其创建为 <code>QueueCorpusScheduler</code>，一个以先进先出方式向模糊器提供测试案例的调度器。</p>
<pre><code class="language-rust ignore">// A queue policy to get testcasess from the corpus
let scheduler = QueueCorpusScheduler::new();

// A fuzzer with feedbacks and a corpus scheduler
let mut fuzzer = StdFuzzer::new(scheduler, (), ());
</code></pre>
<p>最后，我们需要一个 <code>Executor</code>，它是负责运行我们被测试程序的实体。在这个例子中，我们想在进程中运行 <code>harness</code> 函数 (例如，不 fork 出一个子程序) ，因此我们使用 <code>InProcessExecutor</code>。</p>
<pre><code class="language-rust ignore">// Create the executor for an in-process function
let mut executor = InProcessExecutor::new(
    &amp;mut harness,
    (),
    &amp;mut fuzzer,
    &amp;mut state,
    &amp;mut mgr,
)
.expect(&quot;Failed to create the Executor&quot;);
</code></pre>
<p>它需要一个 <code>harness</code>、<code>state</code> 和 事件管理器 的引用。我们将在后面讨论第二个参数。
由于执行器期望约束函数返回一个 <code>ExitKind</code> 对象，我们在 <code>harness</code> 函数中添加 <code>ExitKind::Ok</code>。</p>
<p>现在我们有4个主要的实体，可以运行我们的测试，但我们仍然不能生成测试案例。</p>
<p>为此，我们使用一个生成器，<code>RandPrintablesGenerator</code>，它可以生成一串可打印的字节。</p>
<pre><code class="language-rust ignore">use libafl::generators::RandPrintablesGenerator;

// Generator of printable bytearrays of max size 32
let mut generator = RandPrintablesGenerator::new(32);

// Generate 8 initial inputs
state
    .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
    .expect(&quot;Failed to generate the initial corpus&quot;.into());
</code></pre>
<p>现在你可以在你的 <code>main.rs</code> 中添加必要的 <code>use</code> 指令，并编译模糊器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libafl;

use std::path::PathBuf;
use libafl::{
    bolts::{current_nanos, rands::StdRand},
    corpus::{InMemoryCorpus, OnDiskCorpus, QueueCorpusScheduler},
    events::SimpleEventManager,
    executors::{inprocess::InProcessExecutor, ExitKind},
    fuzzer::StdFuzzer,
    generators::RandPrintablesGenerator,
    inputs::{BytesInput, HasTargetBytes},
    monitors::SimpleMonitor,
    state::StdState,
};
<span class="boring">}
</span></code></pre></pre>
<p>运行时，你应该看到类似的东西:</p>
<pre><code class="language-sh">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/baby_fuzzer`
[LOG Debug]: Loaded 0 over 8 initial testcases
</code></pre>
<h2 id="用反馈来进化语料库"><a class="header" href="#用反馈来进化语料库">用反馈来进化语料库</a></h2>
<p>现在你只是运行了8个随机生成的测试案例，但其中没有一个被存储在语料库中。如果你非常幸运，也许你偶然触发了崩溃，但你在 <code>crashes</code> 中没有看到任何保存的文件。</p>
<p>现在我们想把我们的简单模糊器变成一个基于反馈的模糊器，增加产生正确的输入来触发崩溃的机会。我们将根据达到崩溃所需的3个条件来实现一个简单的反馈。</p>
<p>要做到这一点，我们需要一种方法来跟踪一个条件是否被满足。为模糊器提供模糊运行属性信息的组件，即我们案例中的满足条件，是观察者。我们使用 <code>StdMapObserver</code> ，这是一个默认的观察者，它使用一个 map 来跟踪覆盖的元素。在我们的模糊器中，每个条件都被映射到这种 map 的一个条目。</p>
<p>我们将这样的 map 表示为一个 <code>static mut</code> 变量。
由于我们不依赖于任何插桩引擎，我们必须手动跟踪 map 中被测试函数的满足条件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libafl;
use libafl::{
    inputs::{BytesInput, HasTargetBytes},
    executors::ExitKind,
};

// Coverage map with explicit assignments due to the lack of instrumentation
static mut SIGNALS: [u8; 16] = [0; 16];

fn signals_set(idx: usize) {
    unsafe { SIGNALS[idx] = 1 };
}

// The closure that we want to fuzz
let mut harness = |input: &amp;BytesInput| {
    let target = input.target_bytes();
    let buf = target.as_slice();
    signals_set(0);
    if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
        signals_set(1);
        if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
            signals_set(2);
            if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                panic!(&quot;=)&quot;);
            }
        }
    }
    ExitKind::Ok
};
<span class="boring">}
</span></code></pre></pre>
<p>观察者可以直接从 <code>SIGNALS</code> map 中创建，方法如下:</p>
<pre><code class="language-rust ignore">// Create an observation channel using the signals map
let observer = StdMapObserver::new(&quot;signals&quot;, unsafe { &amp;mut SIGNALS });
</code></pre>
<p>观察者通常被保存在相应的执行器中，因为它们所记录的信息只对一次运行有效。然后我们必须修改我们的 <code>InProcessExecutor</code> 创建，以包括观察者，如下所示:</p>
<pre><code class="language-rust ignore">// Create the executor for an in-process function with just one observer
let mut executor = InProcessExecutor::new(
    &amp;mut harness,
    tuple_list!(observer),
    &amp;mut fuzzer,
    &amp;mut state,
    &amp;mut mgr,
)
.expect(&quot;Failed to create the Executor&quot;.into());
</code></pre>
<p>既然模糊器可以观察到哪个条件被满足，我们就需要一种方法，根据这种观察来评定一个输入是否有趣 (即值得添加到语料库中) 。这里有一个反馈的概念，反馈是状态的一部分，它提供了一种将输入及其相应的执行评为有趣的方式，在观察者中寻找信息。反馈可以在一个所谓的 <code>FeedbackState</code> 实例中保持到目前为止所看到的信息的累积状态，在我们的例子中，它保持了在以前的运行中满足的条件的集合。</p>
<p>我们使用 <code>MaxMapFeedback</code>，这个反馈在 <code>MapObserver</code> 的 map 上实现了新奇的搜索。基本上，如果观察者的 map 中有一个值大于迄今为止为同一条目记录的最大值，它就会将该输入评为有趣的输入，并更新其状态。</p>
<p>反馈也被用来决定一个输入是否是一个 &quot;solutions&quot;。做到这一点的反馈被称为目标反馈，当它将一个输入评为有趣时，它不会被保存到语料库中，而是被保存到解决方案中，在我们的例子中被写在 <code>crash</code> 文件夹中。我们使用 <code>CrashFeedback</code> 来告诉模糊器，如果一个输入导致程序崩溃，那就是我们的解决方案。</p>
<p>我们需要更新我们的状态创建，包括反馈状态和模糊器，包括反馈和目标。</p>
<pre><code class="language-rust ignore">extern crate libafl;
use libafl::{
    bolts::{current_nanos, rands::StdRand, tuples::tuple_list},
    corpus::{InMemoryCorpus, OnDiskCorpus},
    feedbacks::{MapFeedbackState, MaxMapFeedback, CrashFeedback},
    fuzzer::StdFuzzer,
    state::StdState,
    observers::StdMapObserver,
};

// The state of the edges feedback.
let feedback_state = MapFeedbackState::with_observer(&amp;observer);

// Feedback to rate the interestingness of an input
let feedback = MaxMapFeedback::new(&amp;feedback_state, &amp;observer);

// A feedback to choose if an input is a solution or not
let objective = CrashFeedback::new();

// create a State from scratch
let mut state = StdState::new(
    // RNG
    StdRand::with_seed(current_nanos()),
    // Corpus that will be evolved, we keep it in memory for performance
    InMemoryCorpus::new(),
    // Corpus in which we store solutions (crashes in this example),
    // on disk so the user can get them after stopping the fuzzer
    OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
    // States of the feedbacks.
    // They are the data related to the feedbacks that you want to persist in the State.
    tuple_list!(feedback_state),
);

// ...

// A fuzzer with feedbacks and a corpus scheduler
let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</code></pre>
<h2 id="实际的模糊处理"><a class="header" href="#实际的模糊处理">实际的模糊处理</a></h2>
<p>现在，在包括正确的 <code>use</code> 之后，我们可以运行这个程序了，但结果与之前的并没有什么不同，因为随机生成器并没有考虑到我们在语料库中保存的有趣内容。要做到这一点，我们需要插入一个 <code>Mutator</code>。</p>
<p>LibAFL 的另一个核心组件是状态，它是对来自语料库的单个输入所做的动作。例如，<code>MutationalStage</code> 对输入进行突变，并多次执行。</p>
<p>作为最后一步，我们创建了一个突变状态，它使用了一个受 AFL 的 havoc 突变器启发的突变器。</p>
<pre><code class="language-rust ignore">use libafl::{
    mutators::scheduled::{havoc_mutations, StdScheduledMutator},
    stages::mutational::StdMutationalStage,
    fuzzer::Fuzzer,
};

// ...

// Setup a mutational stage with a basic bytes mutator
let mutator = StdScheduledMutator::new(havoc_mutations());
let mut stages = tuple_list!(StdMutationalStage::new(mutator));

fuzzer
    .fuzz_loop(&amp;mut stages, &amp;mut executor, &amp;mut state, &amp;mut mgr)
    .expect(&quot;Error in the fuzzing loop&quot;);
</code></pre>
<p><code>fuzz_loop</code> 将使用调度器为每个迭代向模糊器请求一个测试案例，然后它将调用状态。</p>
<p>加入这段代码后，我们就有了一个合适的模糊器，它可以在一秒钟内找到让函数崩溃的输入。</p>
<pre><code class="language-text">$ cargo run
   Compiling baby_fuzzer v0.1.0 (/home/andrea/Desktop/baby_fuzzer)
    Finished dev [unoptimized + debuginfo] target(s) in 1.56s
     Running `target/debug/baby_fuzzer`
[New Testcase] clients: 1, corpus: 2, objectives: 0, executions: 1, exec/sec: 0
[LOG Debug]: Loaded 1 over 8 initial testcases
[New Testcase] clients: 1, corpus: 3, objectives: 0, executions: 804, exec/sec: 0
[New Testcase] clients: 1, corpus: 4, objectives: 0, executions: 1408, exec/sec: 0
thread 'main' panicked at '=)', src/main.rs:35:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Crashed with SIGABRT
Child crashed!
[Objective] clients: 1, corpus: 4, objectives: 1, executions: 1408, exec/sec: 0
Waiting for broker...
Bye!
</code></pre>
<p>正如你所看到的，在崩溃信息之后，日志的 <code>objectives</code> 计数增加 1，你会在 <code>crashes/</code> 中找到崩溃的输入。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="getting_started/crates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="core_concepts/core_concepts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="getting_started/crates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="core_concepts/core_concepts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
