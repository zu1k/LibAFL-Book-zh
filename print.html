<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LibAFL模糊测试库</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="libafl.html">LibAFL模糊测试库</a></li><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="getting_started/getting_started.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/setup.html"><strong aria-hidden="true">1.1.</strong> 设置</a></li><li class="chapter-item expanded "><a href="getting_started/build.html"><strong aria-hidden="true">1.2.</strong> 构建</a></li><li class="chapter-item expanded "><a href="getting_started/crates.html"><strong aria-hidden="true">1.3.</strong> Crates</a></li></ol></li><li class="chapter-item expanded "><a href="baby_fuzzer.html"><strong aria-hidden="true">2.</strong> 简单的模糊器实例</a></li><li class="chapter-item expanded "><a href="core_concepts/core_concepts.html"><strong aria-hidden="true">3.</strong> 核心概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core_concepts/observer.html"><strong aria-hidden="true">3.1.</strong> 观察者 Observer</a></li><li class="chapter-item expanded "><a href="core_concepts/executor.html"><strong aria-hidden="true">3.2.</strong> 执行器 Executor</a></li><li class="chapter-item expanded "><a href="core_concepts/feedback.html"><strong aria-hidden="true">3.3.</strong> 反馈 Feedback</a></li><li class="chapter-item expanded "><a href="core_concepts/input.html"><strong aria-hidden="true">3.4.</strong> 输入 Input</a></li><li class="chapter-item expanded "><a href="core_concepts/corpus.html"><strong aria-hidden="true">3.5.</strong> 语料库 Corpus</a></li><li class="chapter-item expanded "><a href="core_concepts/mutator.html"><strong aria-hidden="true">3.6.</strong> 突变器 Mutator</a></li><li class="chapter-item expanded "><a href="core_concepts/generator.html"><strong aria-hidden="true">3.7.</strong> 生成器 Generator</a></li><li class="chapter-item expanded "><a href="core_concepts/stage.html"><strong aria-hidden="true">3.8.</strong> 阶段 Stage</a></li></ol></li><li class="chapter-item expanded "><a href="design/design.html"><strong aria-hidden="true">4.</strong> 设计</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="design/architecture.html"><strong aria-hidden="true">4.1.</strong> 架构</a></li><li class="chapter-item expanded "><a href="design/metadata.html"><strong aria-hidden="true">4.2.</strong> 元数据</a></li></ol></li><li class="chapter-item expanded "><a href="message_passing/message_passing.html"><strong aria-hidden="true">5.</strong> 消息传递</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message_passing/spawn_instances.html"><strong aria-hidden="true">5.1.</strong> 生成实例</a></li><li class="chapter-item expanded "><a href="message_passing/configurations.html"><strong aria-hidden="true">5.2.</strong> 配置</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial/tutorial.html"><strong aria-hidden="true">6.</strong> 教程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/intro.html"><strong aria-hidden="true">6.1.</strong> 简介</a></li></ol></li><li class="chapter-item expanded "><a href="advanced_features/advanced_features.html"><strong aria-hidden="true">7.</strong> 高级功能</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced_features/concolic/concolic.html"><strong aria-hidden="true">7.1.</strong> 同心追踪和混合模糊</a></li><li class="chapter-item expanded "><a href="advanced_features/no_std/no_std.html"><strong aria-hidden="true">7.2.</strong> LibAFL在 no_std 环境下 (内核、管理程序...) </a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">LibAFL模糊测试库</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="libafl模糊测试库"><a class="header" href="#libafl模糊测试库">LibAFL模糊测试库</a></h1>
<img align="right" src="https://github.com/AFLplusplus/Website/raw/master/static/logo_256x256.png" alt="AFL++ logo">
<p><em>作者: Andrea Fioraldi 和 Dominik Maier</em></p>
<p>欢迎来到 LibAFL，一个高级模糊测试库，本书是对该库的一个简单介绍。</p>
<p>此版本的 <code>LibAFL Book</code> 是与该库的 <code>1.0</code> 测试版结合在一起的。</p>
<p>本文件仍在进行中，并不完整。这里解释的结构和概念在未来的修订中可能会有变化，因为 LibAFL 的结构本身也会有变化。</p>
<p>本书的 HTML 版本可在 <a href="https://aflplus.plus/libafl-book/">https://aflplus.plus/libafl-book/</a> 在线获取，也可从 LibAFL 仓库中的 <code>docs/</code> 文件夹中离线获取。</p>
<p>使用这个文件夹中的 <code>mdbook build</code> 来构建它，或者运行 <code>mdbook serve</code> 来查看该书。</p>
<p>本书的简体中文版本由 <a href="https://github.com/zu1k">zu1k</a> 翻译，HTML 版本可在 <a href="https://libafl-book-zh.lgf.im">https://libafl-book-zh.lgf.im</a> 在线获取，仓库 <a href="https://github.com/zu1k/libafl-book-zh">zu1k/libafl-book-zh</a>，当前查看版本对应英文原版 <a href="https://github.com/AFLplusplus/LibAFL/tree/4f6f76e85710d3d8d3fd7bea49e2c3f3b152b0e9">4f6f76e</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>模糊器是安全研究人员和开发人员的重要工具。
一系列最先进的工具，如 <a href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a>、<a href="https://llvm.org/docs/LibFuzzer.html">libFuzzer</a> 或 <a href="https://github.com/google/honggfuzz">honggfuzz</a> 都可供用户使用。它们以一种非常有效的方式完成它们的工作，发现成千上万的bug。</p>
<p>然而，从一个高级用户的角度来看，这些工具是有限的，它们的设计并没有把可扩展性作为第一等公民。
通常情况下，模糊器开发者可以选择 Fork 这些现有的工具，或者从头开始创建一个新的模糊器。在这些情况下，研究人员最终得到有大量的模糊器，它们之间互不兼容，其先进的部分进能够被其自己使用。
在这个过程中，需要一遍又一遍的重新发明轮子，而这些过程完全可以被避免。</p>
<p>为了解决这个问题，我们创建了LibAFL，这是一个库，它不只是一个模糊器，而是一个可重复使用的个体模糊器的集合。
LibAFL是用Rust编写的，它可以帮助你开发一个为你的特定需求而定制的模糊器。
无论是一个特定的目标，一个特定的插桩后端，还是一个自定义的突变器，你都可以利用现有的碎片来制作你能想到的最快、最有效的模糊器。</p>
<h2 id="为什么使用-libafl"><a class="header" href="#为什么使用-libafl">为什么使用 LibAFL?</a></h2>
<p>LibAFL为你提供了许多现成的模糊器的优点，同时又是完全可定制的。</p>
<p>目前的一些亮点功能包括:</p>
<ul>
<li><strong>多平台</strong>: LibAFL 几乎可以在任何 Rust编译器 支持的地平台工作，我们已经在 <em>Windows</em>、<em>Android</em>、<em>MacOS</em> 和 <em>Linux</em> 上使用，在 <em>x86_64</em>、<em>aarch64</em> 上使用</li>
<li><strong>移植性</strong>: LibAFL 可以在 <code>no_std</code> 模式下构建，这意味着它不需要依赖特定的操作系统。通过定义一个分配器和映射页面的方法，你可以把LibAFL注入到其他目标平台，如嵌入式设备、管理程序，甚至可能是WebAssembly</li>
<li><strong>适应性</strong>: 鉴于多年来对 <em>AFLplusplus</em> 的开发经验和我们对模糊测试的学术背景，我们可以将最近的模糊测试发展趋势融入到LibAFL的设计中，使其面向未来。
举个例子，相对于老式的模糊器， <code>BytesInput</code> 只是输入的潜在形式之一，你可以自由地使用和修改抽象语法树，以实现结构化的模糊处理。</li>
<li><strong>扩展性</strong>: 作为LibAFL的一部分，我们开发了 <code>低水平消息传递</code> ，简称 <code>LLMP</code> ，它允许LibAFL在核心上几乎线性扩展。也就是说，如果你选择使用这个功能--毕竟这是你的模糊器。
使用LLMP的 <code>broker2broker</code> 功能，通过TCP扩展到多台机器也是可能的</li>
<li><strong>快速</strong>: 我们在编译时尽一切努力，使运行时的开销尽可能小</li>
<li><strong>任何目标</strong>: 我们支持纯二进制模式，如 <strong>QEMU-Mode</strong>、<strong>Frida-Mode</strong>、<strong>ASAN</strong>、<strong>CmpLog</strong>，以及基于资源的插桩的多个编译通道。当然，我们也支持自定义插桩，正如你在基于谷歌Atheris的Python例子中看到的那样</li>
<li><strong>可用性</strong>: 这个问题由你来决定。尽情发挥吧!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入门"><a class="header" href="#入门">入门</a></h1>
<p>要开始使用LibAFL，有一些初始步骤要做。</p>
<p>在本章中，我们将讨论如何使用 Rust 的 <code>cargo</code> 命令下载和构建 LibAFL。
我们还描述了LibAFL的组件结构，即所谓的 <code>crate</code> ，以及每个单独 <code>crate</code> 的目的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置"><a class="header" href="#设置">设置</a></h1>
<p>第一步是下载 LibAFL 和所有没有被 <code>cargo</code> 自动安装的依赖项。</p>
<blockquote>
<h3 id="命令行符号"><a class="header" href="#命令行符号">命令行符号</a></h3>
<p>在本章和全书中，我们展示了一些终端内容。终端输入的行都以<code>$</code>开头，但你不需要输入<code>$</code>字符；
它表示每个命令的开始。不以&quot;$&quot;开头的行通常显示的是 &gt; 前一条命令的输出。
此外，PowerShell特定的例子将使用<code>&gt;</code>而不是<code>$</code>。</p>
</blockquote>
<p>虽然技术上你不需要安装 LibAFL，而是可以直接使用 crates.io 的版本，但我们还是建议下载或克隆 GitHub版本，这样你就可以得到示例模糊器、额外的实用程序和最新的补丁。</p>
<p>最简单的方法是使用 <code>git</code>:</p>
<pre><code class="language-sh">$ git clone git@github.com:AFLplusplus/LibAFL.git
</code></pre>
<p>你也可以在 类UNIX 的机器上，下载一个压缩的存档，然后用以下方法解压:</p>
<pre><code class="language-sh">$ wget https://github.com/AFLplusplus/LibAFL/archive/main.tar.gz
$ tar xvf LibAFL-main.tar.gz
$ rm LibAFL-main.tar.gz
$ ls LibAFL-main # this is the extracted folder
</code></pre>
<h2 id="安装-clang"><a class="header" href="#安装-clang">安装 Clang</a></h2>
<p>LibAFL 的外部依赖之一是 Clang C/C++ 编译器。
虽然大部分代码都是纯Rust语言编写，但我们仍然需要一个C语言编译器，因为稳定的Rust仍然不支持LibAFL某些部分可能需要的功能，比如弱连接以及LLVM内置链接。
对于这些部分，我们使用C语言来向我们的Rust代码库暴露缺少的功能。</p>
<p>此外，如果你想对 C/C++ 应用程序进行源码级模糊测试，你可能需要Clang及其插桩选项来编译被测程序。</p>
<p>在Linux上，你可以使用你的发行版的软件包管理器来获取Clang，但这些软件包并不总是最新的。
相反，我们建议使用来自 LLVM 的 Debian/Ubuntu 预编译包，这些包可以通过他们的 <a href="https://apt.llvm.org/">官方仓库</a> 获得。</p>
<p>对于Microsoft Windows，你可以下载 LLVM 定期生成的 <a href="https://llvm.org/builds/">安装包</a>。</p>
<p>尽管 Clang 是 MacOS 上的默认C编译器，但我们不鼓励使用苹果公司提供的编译器，而鼓励使用从 <a href="https://brew.sh/">Homebrew</a> 安装的版本: <code>brew install llvm</code>。</p>
<p>另外，你也可以下载LLVM源码并自行构建，按照 <a href="https://clang.llvm.org/get_started.html">这里</a> 的方法。</p>
<h2 id="安装-rust"><a class="header" href="#安装-rust">安装 Rust</a></h2>
<p>如果你没有安装 Rust，你可以很容易地按照 <a href="https://www.rust-lang.org/tools/install">这里</a> 描述的步骤来安装它。</p>
<p>请注意，Linux 发行版中的 Rust 版本可能已经过时，LibAFL 总是使用最新的<strong>稳定</strong>版本，可通过 <code>rustup upgrade</code> 获得。</p>
<p>我们建议先安装 Clang 和 LLVM，然后再安装 Rust。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建-libafl"><a class="header" href="#构建-libafl">构建 LibAFL</a></h1>
<p>LibAFL 和大多数 Rust 项目一样，可以使用 <code>cargo</code> 从项目的根目录下构建:</p>
<pre><code class="language-sh">$ cargo build --release
</code></pre>
<p>请注意，<code>--release</code>在开发测试时是可选项，但使用Debug版本进行模糊测试可能会有10倍以上的性能损失，正式使用时你需要添加 <code>--release</code> 标志才能获得正常的速度。</p>
<p>LibAFL资源库是由多个板块组成的。
顶层的 <a href="https://github.com/AFLplusplus/LibAFL/blob/main/Cargo.toml"><code>Cargo.toml</code></a> 是将这些板块分组的工作区文件。
从根目录调用 <code>cargo build</code> 将编译工作区中的所有板块。</p>
<h2 id="构建示例模糊器"><a class="header" href="#构建示例模糊器">构建示例模糊器</a></h2>
<p>对于有经验的 rustaceans 来说，最好的起点是阅读并改编示例模糊器。</p>
<p>我们将这些模糊程序放在 LibAFL 资源库的 <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers"><code>./fuzzers</code></a> 目录下，该目录包含一组不属于工作区的crates。</p>
<p>这些示例模糊器中的每一个都使用了 LibAFL 的特定功能，有时与不同的插桩后端相结合 (例如 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>, <a href="https://frida.re/">Frida</a>, ...) 。</p>
<p>你可以使用这些 crates 作为例子，并作为具有类似功能集的自定义模糊器的骨架。
每个模糊器的目录中都有一个 <code>README.md</code> 文件，描述模糊器及其特性。</p>
<p>要建立一个例子的模糊器，你必须从其各自的文件夹 (<code>fuzzers/[FUZZER_NAME]</code>) 调用 <code>cargo build --release</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>LibAFL 是由不同的 crate 组成的。
crate 是 Rust 的 Cargo 构建系统中的一个独立的库，你可以通过把它添加到你的项目的 <code>Cargo.toml</code> 文件中来使用，比如:</p>
<pre><code class="language-toml">[dependencies]
libafl = { version = &quot;*&quot; }
</code></pre>
<p>对于 LibAFL 来说，每个 crate 都有其独立的用途，用户可能不需要在其项目中使用所有的 crate。</p>
<p>按照项目根目录下的文件夹的命名惯例，它们是:</p>
<h3 id="libafl"><a class="header" href="#libafl"><a href="https://github.com/AFLplusplus/LibAFL/tree/main/libafl"><code>libafl</code></a></a></h3>
<p>这是 主crate，包含了构建模糊器所需的所有组件。</p>
<p>这个板块有许多 Feature标志，可以启用和禁用 LibAFL 的某些方面。
这些特性可以在 <a href="https://github.com/AFLplusplus/LibAFL/blob/main/libafl/Cargo.toml">LibAFL's <code>Cargo.toml</code></a> &quot;<code>[features]</code>&quot;下找到，并且通常在那里有注释说明。
一些值得注意的特性是。</p>
<ul>
<li><code>std</code>: 启用代码中使用Rust标准库的部分。如果没有这个标志，LibAFL是 <code>no_std</code> 兼容的，这将禁用一系列功能，但允许我们在嵌入式环境中使用LibAFL，阅读 <a href="getting_started/../advanced_features/no_std/no_std.html">no_std`部分</a> 了解更多细节</li>
<li><code>derive</code>: 可以使用 LibAFL 的 libafl_derive 中定义的 <code>derive(...)</code> 宏</li>
<li><code>rand_trait</code>: 允许你在需要与Rust的 <a href="https://crates.io/crates/rand"><code>rand</code> crate</a> 兼容的地方使用LibAFL的非常快速 (<em>但不安全！</em>) 的随机数发生器</li>
<li><code>llmp_bind_public</code>: 使 LibAFL 的 LLMP 绑定到一个公共的TCP端口，其他的fuzzers节点可以通过这个端口与这个实例通信</li>
<li><code>introspection</code>: 为LibAFL添加性能统计</li>
</ul>
<p>你可以通过在你的 <code>Cargo.toml</code> 中为 LibAFL 使用 <code>features = [&quot;feature1&quot;, &quot;feature2&quot;, ...]</code> 来选择特性。
在这个列表中，默认情况下，<code>std</code>、<code>derive</code> 和 <code>rand_trait</code> 已经被设置。你可以通过在你的 <code>Cargo.toml</code> 中设置 <code>default-features = false</code> 来选择禁用它们。</p>
<h3 id="libafl_sugar"><a class="header" href="#libafl_sugar">libafl_sugar</a></h3>
<p>sugar crate 抽离了 LibAFL API 的大部分复杂性。
它的目标不是高灵活性，而是高层次和易于使用。
它不像从每个单独的组件中缝合你的模糊器那样灵活，但允许你用最少的代码行建立一个模糊器。
要看它的运行情况，请看一下<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/libfuzzer_stb_image_sugar"><code>libfuzzer_stb_image_sugar</code>示例模糊器</a>。</p>
<h3 id="libafl_derive"><a class="header" href="#libafl_derive">libafl_derive</a></h3>
<p>这是一个与 <code>libafl</code> crate 配对的 proc-macro 板块。</p>
<p>目前，它只是暴露了 <code>derive(SerdeAny)</code> 宏，可以用来定义 Metadata 结构，详见关于 <a href="getting_started/../design/metadata.html">Metadata</a> 的部分。</p>
<h3 id="libafl_targets"><a class="header" href="#libafl_targets">libafl_targets</a></h3>
<p>这个板块提供了与目标交互的代码，并对其进行检测。
为了在编译时启用和禁用功能，使用功能标志来启用和禁用这些功能。</p>
<p>目前，支持的标志有:</p>
<ul>
<li><code>pcguard_edges</code>: 定义了 SanitizerCoverage trace-pc-guard 钩子来跟踪 map 中的执行边</li>
<li><code>pcguard_hitcounts</code>: 定义了 SanitizerCoverage trace-pc-guard 钩子，以追踪 map 中已执行的边和hitcounts (如AFL) </li>
<li><code>libfuzzer</code>: 提供了一个 libFuzzer 风格的兼容层</li>
<li><code>value_profile</code>: 定义了 SanitizerCoverage trace-cmp 钩子，以跟踪 map 中每个比较的匹配位</li>
</ul>
<h3 id="libafl_cc"><a class="header" href="#libafl_cc">libafl_cc</a></h3>
<p>这是一个提供实用程序的库，用于包装编译器和创建源码级模糊器。</p>
<p>目前，只有Clang编译器被支持。
为了更深入地了解它，请看一下教程和例子。</p>
<h3 id="libafl_frida"><a class="header" href="#libafl_frida">libafl_frida</a></h3>
<p>这个库将 LibAFL 与 Frida 作为插桩分析的后端连接起来。</p>
<p>有了这个库，你就可以对 Linux/MacOS/Windows/Android 上的目标进行覆盖率采集。</p>
<p>此外，它还支持 CmpLog 和 AddressSanitizer 插桩和 aarch64 的运行时。</p>
<h3 id="libafl_qemu"><a class="header" href="#libafl_qemu">libafl_qemu</a></h3>
<p>这个库将 LibAFL 与 QEMU 用户模式连接起来，以模糊 ELF 跨平台二进制文件。</p>
<p>它可以在 Linux 上工作，并且可以在没有碰撞的情况下收集边缘覆盖率!
它还支持大量的钩子和插桩选项。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一个简单的libafl模糊器"><a class="header" href="#一个简单的libafl模糊器">一个简单的LibAFL模糊器</a></h1>
<p>本章讨论了一个使用 LibAFL API 构建的极其简单的模糊器。
你将学习基本的实体，如 <code>State</code>、<code>Observer</code> 和 <code>Executor</code>。
虽然下面的章节会详细讨论 LibAFL 的组件，但在这里我们介绍基本原理。</p>
<p>我们将对一个简单的 Rust 函数进行模糊处理，该函数在某个条件下会出现panic。这个模糊器将是单线程的，并在崩溃后停止，就像libFuzzer通常做的那样。</p>
<p>你可以在 <a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/baby_fuzzer"><code>fuzzers/baby_fuzzer</code></a> 中找到本教程的完整版本，作为一个模糊器的例子。</p>
<blockquote>
<h3 id="警告"><a class="header" href="#警告">警告</a></h3>
<p>这个示例模糊器对于任何现实世界的使用来说都是太天真了。
它的目的仅仅是为了展示库的主要组件，如果想更深入地了解如何构建一个自定义的模糊器，请直接阅读 <a href="./tutorial/intro.html">Tutorial chapter</a>。</p>
</blockquote>
<h2 id="创建一个项目"><a class="header" href="#创建一个项目">创建一个项目</a></h2>
<p>我们使用 <code>cargo</code> 创建一个新的Rust项目，将 <code>LibAFL</code> 作为一个依赖项。</p>
<pre><code class="language-sh">$ cargo new baby_fuzzer
$ cd baby_fuzzer
</code></pre>
<p>生成的 <code>Cargo.toml</code> 看起来像下面这样: </p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>为了使用 LibAFl，我们必须在 <code>[dependencies]</code> 下增添其依赖 <code>libafl = { path = &quot;path/to/libafl/&quot; }</code>。
如果你愿意，你可以使用 crates.io 的 LibAFL 版本，在这种情况下，你必须使用 <code>libafl = &quot;*&quot;</code> 来获取最新的版本 (或者将其设置为当前版本) 。</p>
<p>由于我们要对Rust代码进行模糊处理，我们希望崩溃不会简单地导致程序退出，而是引发一个 <code>abort</code> ，然后可以被模糊器捕获。
为此，我们在 <a href="https://doc.rust-lang.org/cargo/reference/profiles.html">profiles</a> 中指定 <code>panic = &quot;abort&quot;</code>。</p>
<p>除了这个设置之外，我们还为在发布模式下的编译添加了一些优化标志，最终的 <code>Cargo.toml</code> 应该类似于下面的样子: </p>
<pre><code class="language-toml">[package]
name = &quot;baby_fuzzer&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
libafl = { path = &quot;path/to/libafl/&quot; }

[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
lto = true
codegen-units = 1
opt-level = 3
debug = true
</code></pre>
<h2 id="被测试的函数"><a class="header" href="#被测试的函数">被测试的函数</a></h2>
<p>打开 <code>src/main.rs</code>，我们有一个空的 <code>main</code> 函数。
首先，我们创建一个我们想要模糊处理的闭包。它接受一个缓冲区作为输入，如果它以 <code>abc</code> 开头，就会引起崩溃: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libafl;
use libafl::inputs::{BytesInput, HasTargetBytes};

let mut harness = |input: &amp;BytesInput| {
    let target = input.target_bytes();
    let buf = target.as_slice();
    if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
        if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
            if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                panic!(&quot;=)&quot;);
            }
        }
    }
};
// To test the panic:
// let input = BytesInput::new(&quot;abc&quot;.as_bytes());
// harness(&amp;input);
<span class="boring">}
</span></code></pre></pre>
<h2 id="生成和运行一些测试"><a class="header" href="#生成和运行一些测试">生成和运行一些测试</a></h2>
<p>基于 LibAFL 的模糊测试器使用的主要组件之一是状态，这是一个在模糊测试过程中演变的数据容器。
包括所有的状态，如输入的语料库，当前的rng状态，以及测试案例和运行的潜在 Metadata。
在我们的 <code>main</code> 中，我们创建了一个基本的 State 实例，如下所示。</p>
<pre><code class="language-rust ignore">// create a State from scratch
let mut state = StdState::new(
    // RNG
    StdRand::with_seed(current_nanos()),
    // Corpus that will be evolved, we keep it in memory for performance
    InMemoryCorpus::new(),
    // Corpus in which we store solutions (crashes in this example),
    // on disk so the user can get them after stopping the fuzzer
    OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
    (),
);
</code></pre>
<p>它需要一个随机数发生器，这是模糊器状态的一部分，在这种情况下，我们使用默认的 <code>StdRand</code> ，但你可以选择一个不同的。我们用当前的纳秒数作为种子。</p>
<p>作为第二个参数，它需要一个实现语料库特性的实例，本例中是 <code>InMemoryCorpus</code>。语料库是由模糊器演化出的测试案例的容器，在这种情况下，我们把它全部放在内存中。</p>
<p>我们将在后面讨论最后一个参数。第三个参数是另一个语料库，在这种情况下，用来存储被视为模糊器 &quot;solutions&quot; 的测试案例。对于我们的目的，solutions是触发崩溃的输入。在这种情况下，我们想把它存储在磁盘的 <code>crashes</code> 目录下，这样我们就可以检查它。</p>
<p>另一个必要的组件是 <code>EventManager</code>。它处理一些事件，如在模糊处理过程中向语料库添加测试案例。对于我们的目的，我们使用最简单的一个，它只是用一个 <code>Monitor</code> 实例向用户显示这些事件的信息。</p>
<pre><code class="language-rust ignore">// The Monitor trait defines how the fuzzer stats are displayed to the user
let mon = SimpleMonitor::new(|s| println!(&quot;{}&quot;, s));

// The event manager handle the various events generated during the fuzzing loop
// such as the notification of the addition of a new item to the corpus
let mut mgr = SimpleEventManager::new(mon);
</code></pre>
<p>此外，我们还有 Fuzzer，一个包含一些改变状态的行动的实体。其中一个动作是使用 <code>CorpusScheduler</code> 为模糊器调度测试案例。
我们将其创建为 <code>QueueCorpusScheduler</code>，一个以先进先出方式向模糊器提供测试案例的调度器。</p>
<pre><code class="language-rust ignore">// A queue policy to get testcasess from the corpus
let scheduler = QueueCorpusScheduler::new();

// A fuzzer with feedbacks and a corpus scheduler
let mut fuzzer = StdFuzzer::new(scheduler, (), ());
</code></pre>
<p>最后，我们需要一个 <code>Executor</code>，它是负责运行我们被测试程序的实体。在这个例子中，我们想在进程中运行 <code>harness</code> 函数 (例如，不 fork 出一个子程序) ，因此我们使用 <code>InProcessExecutor</code>。</p>
<pre><code class="language-rust ignore">// Create the executor for an in-process function
let mut executor = InProcessExecutor::new(
    &amp;mut harness,
    (),
    &amp;mut fuzzer,
    &amp;mut state,
    &amp;mut mgr,
)
.expect(&quot;Failed to create the Executor&quot;);
</code></pre>
<p>它需要一个 <code>harness</code>、<code>state</code> 和 事件管理器 的引用。我们将在后面讨论第二个参数。
由于执行器期望约束函数返回一个 <code>ExitKind</code> 对象，我们在 <code>harness</code> 函数中添加 <code>ExitKind::Ok</code>。</p>
<p>现在我们有4个主要的实体，可以运行我们的测试，但我们仍然不能生成测试案例。</p>
<p>为此，我们使用一个生成器，<code>RandPrintablesGenerator</code>，它可以生成一串可打印的字节。</p>
<pre><code class="language-rust ignore">use libafl::generators::RandPrintablesGenerator;

// Generator of printable bytearrays of max size 32
let mut generator = RandPrintablesGenerator::new(32);

// Generate 8 initial inputs
state
    .generate_initial_inputs(&amp;mut fuzzer, &amp;mut executor, &amp;mut generator, &amp;mut mgr, 8)
    .expect(&quot;Failed to generate the initial corpus&quot;.into());
</code></pre>
<p>现在你可以在你的 <code>main.rs</code> 中添加必要的 <code>use</code> 指令，并编译模糊器。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libafl;

use std::path::PathBuf;
use libafl::{
    bolts::{current_nanos, rands::StdRand},
    corpus::{InMemoryCorpus, OnDiskCorpus, QueueCorpusScheduler},
    events::SimpleEventManager,
    executors::{inprocess::InProcessExecutor, ExitKind},
    fuzzer::StdFuzzer,
    generators::RandPrintablesGenerator,
    inputs::{BytesInput, HasTargetBytes},
    monitors::SimpleMonitor,
    state::StdState,
};
<span class="boring">}
</span></code></pre></pre>
<p>运行时，你应该看到类似的东西:</p>
<pre><code class="language-sh">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/baby_fuzzer`
[LOG Debug]: Loaded 0 over 8 initial testcases
</code></pre>
<h2 id="用反馈来进化语料库"><a class="header" href="#用反馈来进化语料库">用反馈来进化语料库</a></h2>
<p>现在你只是运行了8个随机生成的测试案例，但其中没有一个被存储在语料库中。如果你非常幸运，也许你偶然触发了崩溃，但你在 <code>crashes</code> 中没有看到任何保存的文件。</p>
<p>现在我们想把我们的简单模糊器变成一个基于反馈的模糊器，增加产生正确的输入来触发崩溃的机会。我们将根据达到崩溃所需的3个条件来实现一个简单的反馈。</p>
<p>要做到这一点，我们需要一种方法来跟踪一个条件是否被满足。为模糊器提供模糊运行属性信息的组件，即我们案例中的满足条件，是观察者。我们使用 <code>StdMapObserver</code> ，这是一个默认的观察者，它使用一个 map 来跟踪覆盖的元素。在我们的模糊器中，每个条件都被映射到这种 map 的一个条目。</p>
<p>我们将这样的 map 表示为一个 <code>static mut</code> 变量。
由于我们不依赖于任何插桩引擎，我们必须手动跟踪 map 中被测试函数的满足条件。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libafl;
use libafl::{
    inputs::{BytesInput, HasTargetBytes},
    executors::ExitKind,
};

// Coverage map with explicit assignments due to the lack of instrumentation
static mut SIGNALS: [u8; 16] = [0; 16];

fn signals_set(idx: usize) {
    unsafe { SIGNALS[idx] = 1 };
}

// The closure that we want to fuzz
let mut harness = |input: &amp;BytesInput| {
    let target = input.target_bytes();
    let buf = target.as_slice();
    signals_set(0);
    if buf.len() &gt; 0 &amp;&amp; buf[0] == 'a' as u8 {
        signals_set(1);
        if buf.len() &gt; 1 &amp;&amp; buf[1] == 'b' as u8 {
            signals_set(2);
            if buf.len() &gt; 2 &amp;&amp; buf[2] == 'c' as u8 {
                panic!(&quot;=)&quot;);
            }
        }
    }
    ExitKind::Ok
};
<span class="boring">}
</span></code></pre></pre>
<p>观察者可以直接从 <code>SIGNALS</code> map 中创建，方法如下:</p>
<pre><code class="language-rust ignore">// Create an observation channel using the signals map
let observer = StdMapObserver::new(&quot;signals&quot;, unsafe { &amp;mut SIGNALS });
</code></pre>
<p>观察者通常被保存在相应的执行器中，因为它们所记录的信息只对一次运行有效。然后我们必须修改我们的 <code>InProcessExecutor</code> 创建，以包括观察者，如下所示:</p>
<pre><code class="language-rust ignore">// Create the executor for an in-process function with just one observer
let mut executor = InProcessExecutor::new(
    &amp;mut harness,
    tuple_list!(observer),
    &amp;mut fuzzer,
    &amp;mut state,
    &amp;mut mgr,
)
.expect(&quot;Failed to create the Executor&quot;.into());
</code></pre>
<p>既然模糊器可以观察到哪个条件被满足，我们就需要一种方法，根据这种观察来评定一个输入是否有趣 (即值得添加到语料库中) 。这里有一个反馈的概念，反馈是状态的一部分，它提供了一种将输入及其相应的执行评为有趣的方式，在观察者中寻找信息。反馈可以在一个所谓的 <code>FeedbackState</code> 实例中保持到目前为止所看到的信息的累积状态，在我们的例子中，它保持了在以前的运行中满足的条件的集合。</p>
<p>我们使用 <code>MaxMapFeedback</code>，这个反馈在 <code>MapObserver</code> 的 map 上实现了新奇的搜索。基本上，如果观察者的 map 中有一个值大于迄今为止为同一条目记录的最大值，它就会将该输入评为有趣的输入，并更新其状态。</p>
<p>反馈也被用来决定一个输入是否是一个 &quot;solutions&quot;。做到这一点的反馈被称为目标反馈，当它将一个输入评为有趣时，它不会被保存到语料库中，而是被保存到解决方案中，在我们的例子中被写在 <code>crash</code> 文件夹中。我们使用 <code>CrashFeedback</code> 来告诉模糊器，如果一个输入导致程序崩溃，那就是我们的解决方案。</p>
<p>我们需要更新我们的状态创建，包括反馈状态和模糊器，包括反馈和目标。</p>
<pre><code class="language-rust ignore">extern crate libafl;
use libafl::{
    bolts::{current_nanos, rands::StdRand, tuples::tuple_list},
    corpus::{InMemoryCorpus, OnDiskCorpus},
    feedbacks::{MapFeedbackState, MaxMapFeedback, CrashFeedback},
    fuzzer::StdFuzzer,
    state::StdState,
    observers::StdMapObserver,
};

// The state of the edges feedback.
let feedback_state = MapFeedbackState::with_observer(&amp;observer);

// Feedback to rate the interestingness of an input
let feedback = MaxMapFeedback::new(&amp;feedback_state, &amp;observer);

// A feedback to choose if an input is a solution or not
let objective = CrashFeedback::new();

// create a State from scratch
let mut state = StdState::new(
    // RNG
    StdRand::with_seed(current_nanos()),
    // Corpus that will be evolved, we keep it in memory for performance
    InMemoryCorpus::new(),
    // Corpus in which we store solutions (crashes in this example),
    // on disk so the user can get them after stopping the fuzzer
    OnDiskCorpus::new(PathBuf::from(&quot;./crashes&quot;)).unwrap(),
    // States of the feedbacks.
    // They are the data related to the feedbacks that you want to persist in the State.
    tuple_list!(feedback_state),
);

// ...

// A fuzzer with feedbacks and a corpus scheduler
let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
</code></pre>
<h2 id="实际的模糊处理"><a class="header" href="#实际的模糊处理">实际的模糊处理</a></h2>
<p>现在，在包括正确的 <code>use</code> 之后，我们可以运行这个程序了，但结果与之前的并没有什么不同，因为随机生成器并没有考虑到我们在语料库中保存的有趣内容。要做到这一点，我们需要插入一个 <code>Mutator</code>。</p>
<p>LibAFL 的另一个核心组件是状态，它是对来自语料库的单个输入所做的动作。例如，<code>MutationalStage</code> 对输入进行突变，并多次执行。</p>
<p>作为最后一步，我们创建了一个突变状态，它使用了一个受 AFL 的 havoc 突变器启发的突变器。</p>
<pre><code class="language-rust ignore">use libafl::{
    mutators::scheduled::{havoc_mutations, StdScheduledMutator},
    stages::mutational::StdMutationalStage,
    fuzzer::Fuzzer,
};

// ...

// Setup a mutational stage with a basic bytes mutator
let mutator = StdScheduledMutator::new(havoc_mutations());
let mut stages = tuple_list!(StdMutationalStage::new(mutator));

fuzzer
    .fuzz_loop(&amp;mut stages, &amp;mut executor, &amp;mut state, &amp;mut mgr)
    .expect(&quot;Error in the fuzzing loop&quot;);
</code></pre>
<p><code>fuzz_loop</code> 将使用调度器为每个迭代向模糊器请求一个测试案例，然后它将调用状态。</p>
<p>加入这段代码后，我们就有了一个合适的模糊器，它可以在一秒钟内找到让函数崩溃的输入。</p>
<pre><code class="language-text">$ cargo run
   Compiling baby_fuzzer v0.1.0 (/home/andrea/Desktop/baby_fuzzer)
    Finished dev [unoptimized + debuginfo] target(s) in 1.56s
     Running `target/debug/baby_fuzzer`
[New Testcase] clients: 1, corpus: 2, objectives: 0, executions: 1, exec/sec: 0
[LOG Debug]: Loaded 1 over 8 initial testcases
[New Testcase] clients: 1, corpus: 3, objectives: 0, executions: 804, exec/sec: 0
[New Testcase] clients: 1, corpus: 4, objectives: 0, executions: 1408, exec/sec: 0
thread 'main' panicked at '=)', src/main.rs:35:21
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Crashed with SIGABRT
Child crashed!
[Objective] clients: 1, corpus: 4, objectives: 1, executions: 1408, exec/sec: 0
Waiting for broker...
Bye!
</code></pre>
<p>正如你所看到的，在崩溃信息之后，日志的 <code>objectives</code> 计数增加 1，你会在 <code>crashes/</code> 中找到崩溃的输入。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h1>
<p>LibAFL是围绕一些核心概念设计的，我们认为这些概念可以有效地抽象出大多数其他的模糊器设计。</p>
<p>在这里，我们讨论这些概念，并提供一些与其他模糊器相关的例子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="观察者-oberrver"><a class="header" href="#观察者-oberrver">观察者 Oberrver</a></h1>
<p>观察者(Oberrver)，或称观察通道，是一个实体，它向模糊器提供在被测程序执行期间观察到的信息。</p>
<p>观察者所包含的信息在不同的执行过程中是不被保留的。</p>
<p>例如，在执行过程中填充的覆盖率共享 map，以报告由 AFL 和 HonggFuzz 等模糊器使用的执行边缘，可以被认为是一个观察通道。
这种信息在不同的运行中并不保留，它是对程序的动态属性的观察。</p>
<p>就代码而言，在库中，这个实体由 <a href="https://docs.rs/libafl/0/libafl/observers/trait.Observer.html"><code>Oberrver</code></a> 特性描述。</p>
<p>除了保存与目标的最后一次执行有关的易失性数据外，实现这一特性的结构可以定义一些执行钩子，在每个模糊情况前后执行。在这个钩子中，观察者可以修改模糊器的状态。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="执行器-executor"><a class="header" href="#执行器-executor">执行器 Executor</a></h1>
<p>在不同的fuzzers中，这种执行被测程序的概念意味着每次运行都是一样的。
例如，对于像 libFuzzer 这样的内存模糊器来说，执行是对一个被测试函数的调用，而对于像 <a href="https://github.com/IntelLabs/kAFL">kAFL</a> 这样的基于管理程序的模糊器来说，每次运行都会从一个快照启动整个操作系统。</p>
<p>在我们的模型中，执行者(Executor) 是一个实体，它不仅定义了如何执行目标，还定义了所有与目标的单一运行有关的易失性操作。</p>
<p>因此，执行者负责告知程序模糊器要在运行中使用的输入，例如写到一个内存位置或作为参数传递给约束函数。</p>
<p>在我们的模型中，它还可以持有一组与每个执行程序相关的观察者。</p>
<p>在 Rust 中，我们将这个概念与 <a href="https://docs.rs/libafl/0/libafl/executors/trait.Executor.html"><code>Executor</code></a>  trait 绑定。实现这个特性的结构如果想持有一组观察者，也必须实现 <a href="https://docs.rs/libafl/0/libafl/executors/trait.HasObservers.html"><code>HasObservers</code></a>。</p>
<p>默认情况下，我们实现了一些常用的执行器，如 <a href="https://docs.rs/libafl/0/libafl/executors/inprocess/struct.InProcessExecutor.html"><code>InProcessExecutor</code></a>，其目标是提供进程中崩溃检测的线程函数。另一个执行器是 <a href="https://docs.rs/libafl/0/libafl/executors/forkserver/struct.ForkserverExecutor.html"><code>ForkserverExecutor</code></a>，它实现了一个类似于 AFL 的机制，用来生成子进程进行模糊处理。</p>
<p>在创建执行器时，一个常见的模式是包装现有的执行器，例如 <a href="https://docs.rs/libafl/0.6.1/libafl/executors/timeout/struct.TimeoutExecutor.html"><code>TimeoutExecutor</code></a> 包装了一个执行器，并在调用被包装的执行器的原始运行函数之前安装一个超时回调。</p>
<h2 id="inprocessexecutor"><a class="header" href="#inprocessexecutor">InProcessExecutor</a></h2>
<p>让我们从基本情况开始: <code>InProcessExecutor</code>。
这个执行器使用 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html"><em>SanitizerCoverage</em></a> 作为其后端，你可以在 <code>libafl_targets/src/sancov_pcguards</code> 中找到相关代码。在这里，我们分配了一个名为 <code>EDGES_MAP</code> 的 map ，然后我们的编译器包装器编译约束函数，将覆盖率写入这个 map 中。
当你想尽可能快地执行约束函数时，你很可能想使用 <code>InprocessExecutor</code>。 </p>
<p>这里需要注意的是，当你的约束函数有可能出现堆损坏的问题时，你要使用另一个分配器，这样损坏的堆就不会影响到模糊器本身。(例如，我们在一些模糊器中采用 MiMalloc) 。另外，你也可以启用 AddressSanitizer 来编译你的约束函数，以确保你能捕捉到这些堆的错误。</p>
<h2 id="forkserverexecutor"><a class="header" href="#forkserverexecutor">ForkserverExecutor</a></h2>
<p>接下来，我们来看看 <code>ForkserverExecutor</code>。在这种情况下，是 <code>afl-cc</code> (来自AFLplus/AFLplus) 在编译约束函数代码，因此，我们不能再使用 <code>EDGES_MAP</code>。希望我们有 <a href="https://github.com/AFLplusplus/AFLplusplus/blob/2e15661f184c77ac1fbb6f868c894e946cbb7f17/instrumentation/afl-compiler-rt.o.c#L270"><em>a way</em></a> 告诉 forkserver 哪个 map 来记录覆盖率。</p>
<p>你可以从 forkserver 的例子中看到:</p>
<pre><code class="language-rust ignore">//Coverage map shared between observer and executor
let mut shmem = StdShMemProvider::new().unwrap().new_shmem(MAP_SIZE).unwrap();
//let the forkserver know the shmid
shmem.write_to_env(&quot;__AFL_SHM_ID&quot;).unwrap();
let mut shmem_buf = shmem.as_mut_slice();
</code></pre>
<p>这里我们建立一个共享内存区域: <code>shmem</code>，并将其写入环境变量 <code>__AFL_SHM_ID</code>。然后，被检测的二进制文件或 forkerver 会找到这个共享内存区域 (来自上述环境变量) 来记录其覆盖范围。在你的fuzzer方面，你可以将这个shmem map传递给你的 <code>Observer</code>，以获得与任何 <code>Feedback</code> 相结合的覆盖率反馈。</p>
<p><code>ForkserverExecutor</code> 的另一个特点是共享内存测试案例。在正常情况下，突变的输入是通过 <code>.cur_input</code> 文件在 forkerver 和被测二进制之间传递。你可以通过用共享内存传递输入来提高你的 forkserver 模糊器的性能。
参见 AFL++ 的 <a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md#5-shared-memory-fuzzing"><em>documentation</em></a> 或 <code>forkserver_simple/src/program.c</code> 中的fuzzer例子以供参考。 </p>
<p>这很简单，当你调用 <code>ForkserverExecutor::new()</code> 并将 <code>use_shmem_testcase</code> 设为true时，<code>ForkserverExecutor</code> 会将事情设置好，你的约束函数就可以从 <code>__AFL_FUZZ_TESTCASE_BUF</code> 获取输入。</p>
<h2 id="inprocessforkexecutor"><a class="header" href="#inprocessforkexecutor">InprocessForkExecutor</a></h2>
<p>最后，我们来谈谈 <code>InProcessForkExecutor</code>。
<code>InProcessForkExecutor</code> 与 <code>InprocessExecutor</code> 只有一个区别: 它在运行约束函数之前进行 fork ，仅此而已。 
但为什么我们要这样做呢？好吧，在某些情况下，你可能会发现你的约束函数非常不稳定，或者你的约束函数对全局状态造成了破坏。在这种情况下，你想在子进程中执行约束函数运行之前将其 fork ，这样就不会破坏事情。 
然而，我们必须照顾到共享内存，是子进程在运行约束函数代码，并将覆盖范围写到 map 上。 
我们必须使 map 在父进程和子进程之间共享，所以我们将再次使用共享内存。你应该用 <code>pointer_maps</code> (用于 <code>libafl_targes</code>) 功能来编译你的约束函数，这样，我们可以有一个指针: <code>EDGES_MAP_PTR</code>，可以指向任何覆盖图。
在你的fuzzer方面，你可以分配一个共享内存区域，让 <code>EDGES_MAP_PTR</code> 指向你的共享内存。</p>
<pre><code class="language-rust ignore">let mut shmem;
unsafe{
    shmem = StdShMemProvider::new().unwrap().new_shmem(MAX_EDGES_NUM).unwrap();
}
let shmem_buf = shmem.as_mut_slice();
unsafe{
    EDGES_PTR = shmem_buf.as_ptr();
}
</code></pre>
<p>同样，你可以把这个 <code>shmem</code> map 传递给你的 <code>Observer</code> 和 <code>Feedback</code> 以获得覆盖率反馈。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反馈-feedback"><a class="header" href="#反馈-feedback">反馈 Feedback</a></h1>
<p>反馈(Feedback) 是一个将被测程序的执行结果分类为有趣或不有趣的实体。
通常情况下，如果一个执行是有趣的，那么用于输入目标程序的相应输入就会被添加到一个语料库中。</p>
<p>大多数时候，反馈的概念与观察者有很深的联系，但它们是不同的概念。</p>
<p>反馈，在大多数情况下，处理一个或多个观察者报告的信息，以决定执行是否有趣。
<code>有趣</code> 的概念是抽象的，但通常它与新颖性搜索有关 (即有趣的输入是那些达到控制流图中以前未见过的边缘的输入) 。</p>
<p>举个例子，给定一个报告所有内存分配大小的观察者，可以用一个最大化反馈来最大化这些大小，以运动内存消耗方面的病态输入。</p>
<p>在代码方面，该库提供了 <a href="https://docs.rs/libafl/0/libafl/feedbacks/trait.Feedback.html"><code>Feedback</code></a> 和 <a href="https://docs.rs/libafl/0/libafl/feedbacks/trait.FeedbackState.html"><code>FeedbackState</code></a> 特性。
第一个用于实现一个算子，在给定最后一次执行的观察者的状态时，告诉他们这次执行是否有趣。第二个是与 <code>反馈</code> 联系在一起的，它是反馈希望在模糊器的状态中坚持的数据的状态，例如，在基于边缘覆盖率的反馈的情况下，持有到目前为止看到的所有边缘的累积图。</p>
<p>多个反馈可以结合成布尔公式，例如，如果一个执行触发了新的代码路径，或者执行时间比平均执行时间短，就可以认为它是有趣的。<a href="https://docs.rs/libafl/0/libafl/macro.feedback_or.html"><code>feedback_or</code></a>.</p>
<p>TODO目标反馈和快速反馈逻辑运算符</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入-input"><a class="header" href="#输入-input">输入 Input</a></h1>
<p>从形式上看，程序的输入(Input)是指从外部来源获取的影响程序行为的数据。</p>
<p>在我们的抽象模糊器模型中，我们将输入定义为程序输入 (或其一部分) 的内部表示。</p>
<p>在直接的情况下，程序的输入是一个字节数组，在AFL这样的模糊器中，我们正是存储和操作这些字节数组。</p>
<p>但情况并不总是这样。一个程序可能期望的输入不是字节数组 (例如一连串的系统调用) ，而模糊器并不以程序消耗输入的相同方式来表示。</p>
<p>以语法模糊器为例，输入通常是抽象语法树，因为它是一种数据结构，在保持有效性的同时可以很容易地进行操作，但程序期望输入是一个字节数组，所以在执行之前，树被序列化为一个字节的顺序。</p>
<p>在Rust代码中，<a href="https://docs.rs/libafl/0/libafl/inputs/trait.Input.html"><code>Input</code></a> 是一个 <code>trait</code>，只能由可序列化的结构来实现，并且只有拥有的数据作为字段。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语料库-corpus"><a class="header" href="#语料库-corpus">语料库 Corpus</a></h1>
<p>语料库(Corpus) 是存储测试案例的地方。我们将一个测试案例定义为一个输入和一组相关的元数据，例如，执行时间。</p>
<p>语料库可以用不同的方式存储测试用例，例如在磁盘上，或在内存中，或实现缓存以加快磁盘存储。</p>
<p>通常，当一个测试案例被认为是有趣的时候，它就会被添加到语料库中，但是语料库也被用来存储实现目标的测试案例 (比如说，测试程序崩溃) 。</p>
<p>与语料库相关的是，模糊检验器应要求从语料库中挑选下一个测试案例进行模糊检验。LibAFL中的分类法是CorpusScheduler，该实体代表了从语料库中提取测试案例的策略，例如FIFO。</p>
<p>谈到代码，<a href="https://docs.rs/libafl/0/libafl/corpus/trait.Corpus.html"><code>Corpus</code></a> 和 <a href="https://docs.rs/libafl/0/libafl/corpus/trait.CorpusScheduler.html"><code>CorpusScheduler</code></a> 是 trait。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="突变器-mutator"><a class="header" href="#突变器-mutator">突变器 Mutator</a></h1>
<p>突变器(Mutator) 是一个接受一个或多个输入并生成一个新的派生输入的实体。</p>
<p>突变器可以被组成，它们通常与特定的输入类型相联系。</p>
<p>例如，可以有一个 Mutator 在输入上应用不止一种类型的突变。考虑一个字节流的通用突变器，比特翻转只是可能的突变之一，但不是唯一的突变，还有，例如，随机替换一个字节的块的拷贝。</p>
<p>在LibAFL中，<a href="https://docs.rs/libafl/0/libafl/mutators/trait.Mutator.html"><code>Mutator</code></a>是一个 <code>trait</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生成器-generator"><a class="header" href="#生成器-generator">生成器 Generator</a></h1>
<p>生成器(Generator) 是一个旨在从头生成输入的组件。</p>
<p>通常情况下，随机发生器被用来生成随机输入。</p>
<p>生成器在传统上较少用于反馈驱动的模糊测试，但也有例外，如 Nautilus，它使用语法生成器来创建初始语料库，并使用子树生成器作为其语法突变器的突变。</p>
<p>在代码中，<a href="https://docs.rs/libafl/0/libafl/generators/trait.Generator.html"><code>Generator</code></a>是一个 <code>trait</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阶段-stage"><a class="header" href="#阶段-stage">阶段 Stage</a></h1>
<p>阶段(Stage) 是一个对 从语料库中得到的单一输入 进行操作的实体。</p>
<p>例如，一个突变阶段，给定一个语料库的输入，应用一个突变器并执行一次或多次生成的输入。例如，AFL使用输入的性能分数来选择应该调用多少次破坏性的突变。这也可以取决于其他参数，例如，如果我们想只是应用一个连续的比特翻转，那么输入的长度也可以是一个固定的值。</p>
<p>一个阶段也可以是一个分析阶段，例如，Redqueen的着色阶段旨在为测试案例引入更多的熵，或者AFL的修剪阶段旨在减少测试案例的大小。</p>
<p>在LibAFL代码库中，有几个实现 <a href="https://docs.rs/libafl/0/libafl/stages/trait.Stage.html"><code>Stage</code></a> 特性的阶段。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计"><a class="header" href="#设计">设计</a></h1>
<p>在这一章中，我们讨论了我们是如何在考虑到核心概念的情况下设计这个库的，同时允许代码重用和可扩展性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="架构"><a class="header" href="#架构">架构</a></h1>
<p>LibAFL的架构是围绕着一些实体建立的，以允许代码重用和低成本的抽象。</p>
<p>最初，我们开始考虑用一种面向对象的语言来实现LibAFL，比如C++。当我们登陆到Rust时，我们立即改变了想法，因为我们意识到，虽然Rust允许某种OOP模式，但我们可以用一种更理智的方法来构建这个库，就像<a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">本博文</a>中描述的关于Rust中的游戏设计。</p>
<p>LibAFL的代码重用方式是基于组件而不是子类的，但库中仍有一些OOP模式。</p>
<p>考虑到类似的模糊器，你可以观察到大多数时候被修改的数据结构是与测试案例和模糊器全局状态有关的。</p>
<p>除了之前描述的实体外，我们引入了<a href="https://docs.rs/libafl/0.6/libafl/corpus/testcase/struct.Testcase.html"><code>Testcase</code></a>和<a href="https://docs.rs/libafl/0.6/libafl/state/struct.StdState.html"><code>State</code></a>实体。测试案例是存储在语料库中的输入及其元数据的容器 (因此，在实现中，语料库存储测试案例) ，状态包含在运行模糊器时演变的所有元数据，包括语料库。</p>
<p>在实现中，状态只包含可序列化的自有对象，它本身也是可序列化的。有些模糊器可能希望在暂停时序列化其状态，或者在进行进程内模糊处理时，在崩溃时序列化，并在新进程中反序列化，以继续模糊处理，并保留所有元数据。</p>
<p>此外，我们将 &quot;行动 &quot;的实体，如CorpusScheduler和Feedbacks，归入一个共同的地方，即<a href="https://docs.rs/libafl/0.6.1/libafl/fuzzer/struct.StdFuzzer.html">`Fuzzer'</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元数据"><a class="header" href="#元数据">元数据</a></h1>
<p>LibAFL中的元数据是一个自包含的结构，持有与状态或测试案例相关的数据。</p>
<p>在代码方面，元数据可以被定义为一个在SerdeAny寄存器中注册的Rust结构。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate libafl;
extern crate serde;

use libafl::SerdeAny;
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, SerdeAny)]
pub struct MyMetadata {
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>这个结构必须是静态的，所以它不能持有对借用对象的引用。</p>
<p>作为<code>libafl_derive</code>中的proc-macro，用户可以使用<code>libafl::impl_serdeany!(MyMetadata);</code>来替代<code>derive(SerdeAny)</code>。</p>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>元数据对象主要用于<a href="https://docs.rs/libafl/0.5.0/libafl/bolts/serdeany/serdeany_registry/struct.SerdeAnyMap.html"><code>SerdeAnyMap</code></a>和<a href="https://docs.rs/libafl/0.5.0/libafl/bolts/serdeany/serdeany_registry/struct.NamedSerdeAnyMap.html"><code>NamedSerdeAnyMap</code></a>中。</p>
<p>通过这些 map ，用户可以按类型 (和名称) 检索实例。在内部，这些实例被存储为SerdeAny trait 对象。</p>
<p>想拥有一套元数据的结构必须实现<a href="https://docs.rs/libafl/0.5.0/libafl/state/trait.HasMetadata.html"><code>HasMetadata</code></a> trait。</p>
<p>默认情况下，Testcase和State实现了它，并持有一个SerdeAnyMap测试案例。</p>
<h2 id="deserialization"><a class="header" href="#deserialization">(De)Serialization</a></h2>
<p>我们对存储状态的元数据感兴趣，以便在崩溃或模糊器停止的情况下不会丢失它们。要做到这一点，它们必须使用Serde进行序列化和非序列化。</p>
<p>由于元数据是作为 trait 对象存储在SerdeAnyMap中的，所以默认情况下它们不能用Serde进行反序列化。</p>
<p>为了解决这个问题，在LibAFL中，每个SerdeAny结构都必须在一个全局注册表中注册，该注册表可以跟踪类型并允许对注册的类型进行 (反) 序列化。</p>
<p>通常情况下，<code>impl_serdeany</code>宏为用户创建一个构造函数来填充注册表。然而，当在no_std模式下使用LibAFL时，这个操作必须在<code>main</code>函数的任何其他操作之前手动进行。</p>
<p>要做到这一点，开发者需要知道模糊器内部使用的每个元数据类型，并在<code>main</code>的开头为每个元数据调用<code>RegistryBuilder::register::&lt;MyMetadata&gt;()</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h1>
<p>LibAFL提供了一个标准的机制，用于在进程和机器上进行低开销的消息传递。
我们使用消息传递来通知其他连接的客户端/模糊器/节点关于新的测试案例、元数据和关于当前运行的统计数据。
根据个人需要，LibAFL也可以将测试案例的内容写到磁盘上，同时仍然使用事件来通知其他模糊器，使用一个 <code>OnDiskCorpus</code>.</p>
<p>在我们的测试中，消息传递可以很好地在多个运行中的模糊器实例之间分享新的测试案例和元数据，以进行多核模糊处理。
Specifically, it scales <em>a lot</em> better than using memory locks on a shared corpus, and <em>a lot</em> better than sharing the testcases via the filesystem, as AFL traditionally does.
Think &quot;all cores are green&quot; in <code>htop</code>, aka., no kernel interaction.</p>
<p>The <code>EventManager</code> interface is used to send Events over the wire using <code>Low Level Message Passing</code>, a custom message passing mechanism over shared memory or TCP.</p>
<h2 id="low-level-message-passing-llmp"><a class="header" href="#low-level-message-passing-llmp">Low Level Message Passing (LLMP)</a></h2>
<p>LibAFL comes with a reasonably lock-free message passing mechanism that scales well across cores and, using its <em>broker2broker</em> mechanism, even to connected machines via TCP.
Most example fuzzers use this mechanism, and it is the best <code>EventManager</code> if you want to fuzz on more than a single core.
In the following, we will describe the inner workings of <code>LLMP</code>.</p>
<p><code>LLMP</code> has one <code>broker</code> process that can forward messages sent by any client process to all other clients.
The broker can also intercept and filter the messages it receives instead of forwarding them.
经纪人过滤的信息的一个常见用例是每个客户直接发送给经纪人的状态信息。
经纪人用这些信息来绘制一个简单的用户界面，其中有所有客户的最新信息，然而其他客户不需要接收这些信息。</p>
<h3 id="通过共享内存的快速本地消息"><a class="header" href="#通过共享内存的快速本地消息">通过共享内存的快速本地消息</a></h3>
<p>在整个LibAFL中，我们使用了一个围绕不同操作系统的共享 map 的包装器，称为<code>ShMem</code>。
共享 map ，为了不与Rust的<code>map()</code>函数相冲突，被称为共享内存，是<code>LLMP</code>的骨干。
每个客户，通常是试图分享统计数据和新的测试案例的摸索者，都会映射一个输出的<code>ShMem</code> map 。
除了极少数的例外，只有这个客户写到这个 map 上，因此，我们不会在竞赛条件下运行，可以不用锁。
代理人从所有客户的<code>ShMem</code>映射中读取。
它定期检查所有传入的客户端映射，然后将新消息转发到它的出站广播-<code>ShMem</code>，由所有连接的客户端映射。</p>
<p>为了发送新消息，客户端在其共享内存的末端放置一个新消息，然后更新一个静态字段来通知代理。
一旦传出的映射已满，发送者使用各自的<code>ShMemProvider'分配一个新的</code>ShMem'。
然后，它使用页面结束 (<code>EOP</code>) 消息发送所需信息，将连接进程中新分配的页面映射到旧的页面。
一旦接收者映射了新的页面，就把它标记为安全的，可以从发送进程中解除映射 (如果我们在短时间内有超过一个EOP，就可以避免竞赛条件) ，然后继续从新的<code>ShMem</code>中读取。</p>
<p>The schema for client's maps to the broker is as follows:</p>
<pre><code class="language-text">[client0]        [client1]    ...    [clientN]
  |                  |                 /
[client0_out] [client1_out] ... [clientN_out]
  |                 /                /
  |________________/                /
  |________________________________/
 \|/
[broker]
</code></pre>
<p>代理人在所有传入的 map 上循环，并检查新的消息。
在<code>std</code>构建中，经纪人会在循环后睡眠几毫秒，因为我们不需要消息立即到达。
在经纪人收到来自客户端N的新消息后， (<code>clientN_out-&gt;current_id != last_message-&gt;message_id</code>) 经纪人会将消息内容复制到自己的广播共享内存。</p>
<p>客户端定期地，例如在完成<code>n'次突变后，通过检查是否有新的消息进入 (</code>current_broadcast_map-&gt;current_id != last_message-&gt;message_id<code>) 。 虽然经纪人使用相同的EOP机制为其传出的 map 映射新的</code>ShMem'，但它从不解除旧页面的映射。
这种额外的内存开销有一个很好的目的: 通过保留所有的广播页面，我们确保新的客户可以在以后的时间点加入到模糊测试活动中来
他们只需要从头到尾重新阅读所有广播的信息。</p>
<p>所以传出的消息在传出的广播<code>Shmem</code>上是这样流动的。</p>
<pre><code class="language-text">[broker]
  |
[current_broadcast_shmem]
  |
  |___________________________________
  |_________________                  \
  |                 \                  \
  |                  |                  |
 \|/                \|/                \|/
[client0]        [client1]    ...    [clientN]
</code></pre>
<p>要在LibAFL中使用<code>LLMP</code>，你通常要使用<code>LlmpEventManager</code>或其重启的变体。
如果使用 LibAFL 的 <code>Launcher</code>，它们是默认的。</p>
<p>如果你想使用<code>LLMP</code>的原始形式，没有任何<code>LibAFL</code>的抽象，看看<a href="https://github.com/AFLplusplus/LibAFL/blob/main/libafl/examples/llmp_test/main.rs">./libafl/examples</a>中的<code>llmp_test</code>例子。
你可以使用<code>cargo run --example llmp_test</code>以适当的模式运行这个例子，正如其帮助输出所指出的。
首先，你必须使用<code>LlmpBroker::new()</code>创建一个经纪人。
然后，在其他线程中创建一些<code>LlmpClient</code>s<code>，并使用</code>LlmpBroker::register_client<code>在主线程中注册它们。 最后，调用</code>LlmpBroker::loop_forever()`。</p>
<h3 id="b2b-通过tcp连接模糊器"><a class="header" href="#b2b-通过tcp连接模糊器">B2B: 通过TCP连接模糊器</a></h3>
<p>对于 &quot;broker2broker &quot;的通信，所有的广播信息都通过网络套接字转发。
为了方便起见，我们在经纪人中产生了一个额外的客户线程，它可以像其他客户那样读取广播共享内存。
对于broker2的通信，这个b2b客户端监听来自其他远程broker的TCP连接。
它在任何时候都保持一个开放的套接字池，用于连接其他远程的b2b经纪商。
当在本地经纪商共享内存中收到一个新消息时，b2b客户端将通过TCP将其转发给所有连接的远程经纪商。
另外，经纪商可以从所有连接的 (远程) 经纪商那里接收消息，并通过客户端<code>ShMem</code>转发给本地经纪商。</p>
<p>作为附带说明，用于b2b通信的tcp监听器也用于新客户试图连接到本地经纪商时的初始握手，简单地交换初始<code>ShMem</code>描述。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="派生实例"><a class="header" href="#派生实例">派生实例</a></h1>
<p>多个模糊器实例可以通过不同的方式产生。</p>
<h2 id="手动通过一个tcp端口"><a class="header" href="#手动通过一个tcp端口">手动，通过一个TCP端口</a></h2>
<p>做多线程的直接方法是使用<code>LlmpRestartingEventManager</code>，特别是使用<code>setup_restarting_mgr_std</code>。</p>
<p>它抽象化了所有讨厌的细节，如崩溃处理时的重启 (针对内存模糊器) 和多线程。
有了它，你手动启动的每个实例都会尝试连接到本地机器上的一个TCP端口。</p>
<p>如果这个端口还没有被绑定，这个实例就会成为代理，它自己会绑定到这个端口以等待新的客户。</p>
<p>如果该端口已经被绑定，EventManager将尝试连接到它。
该实例成为客户端，现在可以与所有其他节点通信。</p>
<p>手动启动节点的好处是，你可以有多个具有不同配置的节点，比如客户端在有ASAN和没有ASAN的情况下进行模糊处理。</p>
<p>虽然它被称为 &quot;重启 &quot;管理器，但它在Unix操作系统上使用<code>fork</code>作为优化，在Windows上只实际从头开始重启。</p>
<h2 id="launcher"><a class="header" href="#launcher">Launcher</a></h2>
<p>启动器是lazy模式启动多线程。</p>
<p>你可以使用<code>Launcher::builder</code>来创建一个产生多个节点的模糊器，所有这些节点都使用重新启动的事件管理器。</p>
<p>看一个例子:</p>
<pre><code class="language-rust ignore">    Launcher::builder()
        .configuration(EventConfig::from_name(&amp;configuration))
        .shmem_provider(shmem_provider)
        .monitor(mon)
        .run_client(&amp;mut run_client)
        .cores(cores)
        .broker_port(broker_port)
        .stdout_file(stdout_file)
        .remote_broker_addr(broker_addr)
        .build()
        .launch()
</code></pre>
<p>首先启动一个代理，然后根据传递给 <code>cores</code> 的值生成 <code>n</code> 个客户端。
这个值是一个字符串，表示要绑定的核心，例如， <code>0,2,5</code> 或 <code>0-3</code>。
对于每个客户端，<code>run_client'将被调用。 在Windows上，启动器将重新启动每个客户端，而在Unix上，它将使用</code>fork`。</p>
<h2 id="其他方式"><a class="header" href="#其他方式">其他方式</a></h2>
<p>LlmpEvenManager系列是做产卵实例的最简单的方法，但对于不明显的目标，你可能需要想出其他的解决方案。</p>
<p>LLMP甚至在理论上是 <code>no_std</code> 兼容的，甚至完全不同的EventManagers也可以用于消息传递。</p>
<p>如果你遇到这种情况，请阅读当前的实现和/或与我们联系。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configurations"><a class="header" href="#configurations">Configurations</a></h1>
<p>单个模糊器节点的配置与多节点模糊计算有关。
本章介绍了如何在一个模糊测试集群中运行具有不同配置的节点
在一个模糊测试集群中运行不同配置的节点。
例如，这允许一个用ASAN编译的节点知道它需要为一个没有ASAN的节点重新运行新的测试案例，而同样的二进制/配置则不需要。</p>
<blockquote>
<h2 id="正在建设中"><a class="header" href="#正在建设中">正在建设中!</a></h2>
<p>本节正在建设中。
请稍后再来检查 (或打开PR) 。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教程"><a class="header" href="#教程">教程</a></h1>
<p>在本章中，我们将使用Rust中的 <a href="https://github.com/microsoft/lain">Lain</a> 突变器构建一个自定义模糊器。</p>
<p>本教程将向你介绍如何编写LibAFL的扩展，如Feedbacks和Testcase的元数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<blockquote>
<h2 id="正在建设中-1"><a class="header" href="#正在建设中-1">正在建设中!</a></h2>
<p>本节正在建设中。
请稍后再来检查 (或打开一个PR) 。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<p>除了摸索器的核心构建模块，LibAFL还具有更多高级/小众摸索技术的功能。</p>
<p>下面的章节专门介绍这些功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并行追踪和混合模糊测试"><a class="header" href="#并行追踪和混合模糊测试">并行追踪和混合模糊测试</a></h1>
<p>LibAFL支持基于 <a href="https://github.com/eurecom-s3/symcc">SymCC</a> 仪表编译器的协程跟踪。</p>
<p>对于那些没有经验的人来说，下面将尝试用一个例子从头开始描述协程跟踪。
然后，我们将讨论SymCC和LibAFL协程跟踪的关系。
最后，我们将通过使用LibAFL构建一个基本的混合模糊器。</p>
<h2 id="同期追踪的例子"><a class="header" href="#同期追踪的例子">同期追踪的例子</a></h2>
<p>假设你想对以下程序进行模糊处理。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn target(input: &amp;[u8]) -&gt; i32 {
    match &amp;input {
        // fictitious crashing input
        &amp;[1, 3, 3, 7] =&gt; 1337,
        // standard error handling code
        &amp;[] =&gt; -1,
        // representative of normal execution
        _ =&gt; 0 
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>一个简单的覆盖率最大化的模糊器在某种程度上随机地产生新的输入，将很难找到触发虚构的崩溃输入的一个输入。
许多技术被提出来，以使模糊处理不那么随机，而是更直接地试图改变输入，以翻转特定的分支，例如参与崩溃上述程序的分支。</p>
<p>并行追踪允许我们以 <strong>分析的方式而不是</strong> 随机的方式 (即猜测) 构建一个输入，以锻炼程序中的一个新路径 (比如例子中的崩溃路径) 。
原则上，协程跟踪的工作方式是观察程序执行过程中所有依赖输入的执行指令。
为了理解这一点，我们将以上述程序为例进行说明。</p>
<p>首先，我们将程序简化为简单的if-then-else-statements。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn target(input: &amp;[u8]) -&gt; i32 {
    if input.len() == 4 {
        if input[0] == 1 {
            if input[1] == 3 {
                if input[2] == 3 {
                    if input[3] == 7 {
                        return 1337;
                    } else {
                        return 0;
                    }
                } else {
                    return 0;
                }
            } else {
                return 0;
            }
        } else {
            return 0;
        }
    } else {
        if input.len() == 0 {
            return -1;
        } else {
            return 0;
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, we'll trace the program on the input <code>[]</code>.
The trace would look like this:</p>
<pre><code class="language-rust ignore">Branch { // if input.len() == 4
    condition: Equals { 
        left: Variable { name: &quot;input_len&quot; }, 
        right: Integer { value: 4 } 
    }, 
    taken: false // This condition turned out to be false...
}
Branch { // if input.len() == 0
    condition: Equals { 
        left: Variable { name: &quot;input_len&quot; }, 
        right: Integer { value: 0 } 
    }, 
    taken: true // This condition turned out to be true!
}
</code></pre>
<p>利用这个跟踪，我们可以很容易地推断出，我们可以通过一个长度为4的输入或者一个非零长度的输入来迫使程序采取不同的路径。
我们通过否定每个分支条件并分析解决所产生的 &quot;表达式 &quot;来做到这一点。
事实上，我们可以为任何计算创建这些表达式，并把它们交给 <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>-Solver，它将生成一个满足表达式的输入 (只要这种输入存在) 。</p>
<p>在混合模糊计算中，我们将这种追踪+求解的方法与更传统的模糊计算技术相结合。</p>
<h2 id="libaflsymcc和symqemu中的协程跟踪"><a class="header" href="#libaflsymcc和symqemu中的协程跟踪">LibAFL、SymCC和SymQEMU中的协程跟踪</a></h2>
<p>LibAFL中的协程跟踪支持是通过SymCC实现的。
SymCC是clang的一个编译器插件，可以用来替代普通的C或C++编译器。
SymCC将对编译后的代码进行回调，使之成为一个可以由用户提供的运行时。
这些回调允许运行时构建一个类似于前面例子的跟踪。</p>
<h3 id="symcc和它的运行时"><a class="header" href="#symcc和它的运行时">SymCC和它的运行时</a></h3>
<p>SymCC有两个运行时:</p>
<ul>
<li>一个 &quot;简单的 &quot;运行时，它试图用 <a href="https://github.com/Z3Prover/z3/wiki">Z3</a> 来解决它遇到的任何分支，以及</li>
<li>一个基于 <a href="https://github.com/sslab-gatech/qsym">QSym</a> 的运行时，它对表达式进行了更多的过滤，也使用Z3进行求解。</li>
</ul>
<p>然而，与LibAFL的集成需要你使用 <a href="https://docs.rs/symcc_runtime/0.1/symcc_runtime"><code>symcc_runtime</code></a> crate进行 <strong>BYORT</strong> (<em>bring your own runtime</em>) 。
这个工具箱允许你轻松地从内置的构建模块中建立一个自定义的运行时，或者以完全的灵活性创建全新的运行时。
查看 <code>symcc_runtime</code> 文档，了解更多关于如何建立你自己的运行时的信息。</p>
<h3 id="symqemu"><a class="header" href="#symqemu">SymQEMU</a></h3>
<p><a href="https://github.com/eurecom-s3/symqemu">SymQEMU</a> 是SymCC的一个兄弟项目。
它不是在编译时对目标进行检测，而是通过动态二进制翻译插入检测，建立在 <a href="https://www.qemu.org"><code>QEMU</code></a> 仿真栈之上。
这意味着使用SymQEMU，任何 (x86) 二进制文件都可以被追踪，而不需要提前建立插桩。
<code>symcc_runtime</code> 工具箱支持这种使用情况，用 <code>symcc_runtime</code> 构建的运行时也可用于SymQEMU。</p>
<h2 id="libafl中的混合型模糊处理"><a class="header" href="#libafl中的混合型模糊处理">LibAFL中的混合型模糊处理</a></h2>
<p>LibAFL资源库中包含了一个<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/libfuzzer_stb_image_concolic">混合模糊器实例</a>。</p>
<p>使用LibAFL构建一个混合型模糊器主要有三个步骤。</p>
<ol>
<li>建立一个运行时间。</li>
<li>选择一个工具化的方法和</li>
<li>构建模糊器。</li>
</ol>
<p>请注意，这些步骤的顺序是很重要的。
例如，在用SymCC进行插桩分析之前，我们需要先准备好运行时间。</p>
<h3 id="建立一个运行时"><a class="header" href="#建立一个运行时">建立一个运行时</a></h3>
<p>使用<code>symcc_runtime</code>板块可以很容易地构建一个自定义运行时。
注意，自定义运行时是一个单独的共享对象文件，这意味着我们需要一个单独的crate用于我们的运行时。
请查看<a href="https://github.com/AFLplusplus/LibAFL/tree/main/fuzzers/libfuzzer_stb_image_concolic/runtime">混合模糊器的运行时间示例</a>和<a href="https://docs.rs/symcc_runtime/0.1/symcc_runtime"><code>symcc_runtime</code> docs</a>以获得灵感。</p>
<h3 id="工具化"><a class="header" href="#工具化">工具化</a></h3>
<p>在LibAFL中，有两种主要的工具化方法来使用协程跟踪。</p>
<ul>
<li>使用<strong>编译时</strong>插桩化的目标与<strong>SymCC</strong>。
这只有在目标的源代码可用，并且目标很容易使用SymCC编译器包装器构建的情况下才有效。</li>
<li>使用<strong>SymQEMU</strong>在**运行时动态地检测目标。
这避免了一个单独的插桩化目标与协程跟踪插桩化，而且不需要源代码。
然而，应该注意的是，生成的表达式的 &quot;质量 &quot;可能会大大降低，而且SymQEMU通常比SymCC生成的表达式要多得多，而且明显更曲折。
因此，建议尽可能使用SymCC而不是SymQEMU。</li>
</ul>
<h4 id="使用symcc"><a class="header" href="#使用symcc">使用SymCC</a></h4>
<p>在使用SymCC进行模糊测试之前，需要对目标进行检测。
具体如何做并不重要。
然而，SymCC编译器需要知道它应该检测的运行时间的位置。
这可以通过将 <code>SYMCC_RUNTIME_DIR</code> 环境变量设置为包含运行时的目录来实现 (通常是你的运行时板块的 <code>target/(debug|release)</code> 文件夹) 。</p>
<p>混合模糊器的例子在其 <a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/libfuzzer_stb_image_concolic/fuzzer/build.rs#L50"><code>build.rs</code>构建脚本</a> 中检测目标。
它通过克隆和构建SymCC的副本来实现，然后使用这个版本来检测目标。
<a href="https://docs.rs/symcc_libafl"><code>symcc_libafl</code> crate</a> 包含用于克隆和构建SymCC的辅助函数。</p>
<p>在尝试构建SymCC之前，请确保你满足SymCC的 <a href="https://github.com/eurecom-s3/symcc#readme">构建要求</a>。</p>
<h4 id="使用symqemu"><a class="header" href="#使用symqemu">使用SymQEMU</a></h4>
<p>根据SymQEMU的 <a href="https://github.com/eurecom-s3/symqemu#readme">构建说明</a> 来构建它。
默认情况下，SymQEMU会在一个同级目录下寻找运行时。
由于我们没有运行时，我们需要让它知道你的运行时的路径，将 <code>--symcc-build</code> 脚本的参数设置为你的运行时的路径。</p>
<h3 id="构建模糊器"><a class="header" href="#构建模糊器">构建模糊器</a></h3>
<p>无论采用哪种方法，现在模糊器和被检测目标之间的接口应该是一致的。
使用SymCC和SymQEMU的唯一区别应该是代表目标的二进制文件。
在SymCC的情况下，它将是用插桩构建的二进制文件，而在SymQEMU的情况下，它将是模拟器的二进制文件 (例如: <code>x86_64-linux-user/symqemu-x86_64</code>) ，后面是你的非插桩化的目标二进制文件和论据。</p>
<p>你可以使用 <a href="https://docs.rs/libafl/0.6.0/libafl/executors/command/struct.CommandExecutor.html"><code>CommandExecutor</code></a> 来执行你的目标 (<a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/libfuzzer_stb_image_concolic/fuzzer/src/main.rs#L244">example</a>) 。
在配置命令时，如果你的目标从文件中读取输入 (而不是标准输入) ，请确保传递 <code>SYMCC_INPUT_FILE</code> 环境变量的输入文件路径。</p>
<h4 id="序列化和解算"><a class="header" href="#序列化和解算">序列化和解算</a></h4>
<p>虽然完全可以建立一个自定义的运行时，在目标进程的背景下执行混合模糊的求解步骤，但LibAFL协程跟踪支持的预期用途是使用 <a href="https://docs.rs/symcc_runtime/0.1/symcc_runtime/tracing/struct.TracingRuntime.html"><code>TracingRuntime</code></a> 对 (过滤和预处理的) 分支条件进行序列化。
这个序列化的表述可以在模糊程序中被反序列化，以便使用 <a href="https://docs.rs/libafl/0.6.0/libafl/observers/concolic/struct.ConcolicObserver.html"><code>ConcolicObserver</code></a> 包裹在 <a href="https://docs.rs/libafl/0.6.0/libafl/stages/concolic/struct.ConcolicTracingStage.html"><code>ConcolicTracingStage</code></a> 中进行解决，它将在每个 <a href="https://docs.rs/libafl/0.6.0/libafl/corpus/testcase/struct.Testcase.html"><code>TestCase</code></a> 中附加一个 <a href="https://docs.rs/libafl/0.6.0/libafl/observers/concolic/struct.ConcolicMetadata.html"><code>ConcolicMetadata</code></a>。</p>
<p><code>ConcolicMetadata'可以用来重放协程跟踪，并使用SMT-Solver进行解决。 然而，大多数涉及协程跟踪的用例都需要围绕他们想要解决的分支定义一些策略。 [</code>SimpleConcolicMutationalStage`](https://docs.rs/libafl/0.6.0//libafl/stages/concolic/struct.SimpleConcolicMutationalStage.html) 可用于测试目的。
它将尝试解决所有分支，就像SymCC的原始简单后端一样，使用Z3。</p>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<p>这个例子说明了如何使用 <a href="https://github.com/AFLplusplus/LibAFL/blob/main/fuzzers/libfuzzer_stb_image_concolic/fuzzer/src/main.rs#L203"><code>ConcolicTracingStage</code>和<code>SimpleConcolicMutationalStage</code></a> 来建立一个基本的混合模糊器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-no_std-环境中使用-libafl"><a class="header" href="#在-no_std-环境中使用-libafl">在 <code>no_std</code> 环境中使用 LibAFL</a></h1>
<p>可以在 <code>no_std</code> 环境中使用LibAFL，例如自定义平台，如微控制器、内核、管理程序等等。</p>
<p>你可以简单地将 LibAFL 添加到你的 <code>Cargo.toml</code> 文件中:</p>
<pre><code class="language-toml">libafl = { path = &quot;path/to/libafl/&quot;, default-features = false}
</code></pre>
<p>Then build your project e.g. for <code>aarch64-unknown-none</code> using</p>
<pre><code class="language-sh">cargo build --no-default-features --target aarch64-unknown-none
</code></pre>
<h2 id="使用自定义时间戳"><a class="header" href="#使用自定义时间戳">使用自定义时间戳</a></h2>
<p>LibAFL 对 <code>no_std</code> 的最小输入量是一个单调增长的时间戳。
为此，在你项目的任何地方，你需要实现 <code>external_current_millis</code> 函数，它以毫秒为单位返回当前时间。</p>
<p>// 假设这是一个来自自定义stdlib的时钟源，你想使用它，它以秒为单位返回当前时间。</p>
<pre><code class="language-c">int my_real_seconds(void)
{
    return *CLOCK;
}
</code></pre>
<p>而在这里我们在 Rust 中使用它，<code>external_current_millis</code> 会被LibAFL调用。
注意，它需要是 <code>no_mangle</code> ，以便在链接时被 LibAFL 接受。</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn external_current_millis() -&gt; u64 {
    unsafe { my_real_seconds()*1000 }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
