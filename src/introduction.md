# 简介

模糊器是安全研究人员和开发人员的重要工具。
一系列最先进的工具，如 [AFL++](https://github.com/AFLplusplus/AFLplusplus) 、 [libFuzzer](https://llvm.org/docs/LibFuzzer.html) 或 [honggfuzz](https://github.com/google/honggfuzz) 都可供用户使用。它们以一种非常有效的方式完成它们的工作，发现成千上万的bug。

然而，从一个高级用户的角度来看，这些工具是有限的。
它们的设计并没有把可扩展性作为第一等公民。
通常情况下，模糊器开发者可以选择分叉这些现有的工具之一，或者从头开始创建一个新的模糊器。
在任何情况下，研究人员最终都会有大量的模糊器，它们都是互不兼容的。
他们出色的功能不能仅仅为新的项目进行组合。
通过一次又一次地重新发明轮子，我们可能完全错过了那些复杂的重新实现的功能。

为了解决这个问题，我们创建了LibAFL，这是一个库，它不只是另一个模糊器，而是一个可重复使用的个体模糊器的集合。
LibAFL是用Rust编写的，它可以帮助你开发一个为你的特定需求而定制的模糊器。
无论是一个特定的目标，一个特定的仪器后端，还是一个自定义的突变器，你都可以利用现有的碎片来制作你能想到的最快、最有效的模糊器。

## 为什么使用 LibAFL?

LibAFL为你提供了许多现成的模糊器的优点，同时又是完全可定制的。

目前的一些亮点功能包括：

- `多平台`：LibAFL几乎可以在任何你能找到Rust编译器的地方工作。我们已经在 *Windows* 、 *Android* 、 *MacOS* 和 *Linux* 上使用了它，在 *x86_64*、*aarch64* 上使用。
- `可移植`：`LibAFL` 可以在 `no_std` 模式下构建。
这意味着它不需要一个特定的依赖操作系统的运行时间来运作。
定义一个分配器和映射页面的方法，你就可以把LibAFL注入到不知名的目标中，如嵌入式设备、管理程序，甚至可能是WebAssembly？
- `可定制性`：鉴于多年来对 *AFLplusplus* 的微调经验和我们的学术模糊背景，我们可以将最近的模糊趋势纳入LibAFL的设计中，使其面向未来。
举个例子，相对于老式的模糊器， `BytesInput` 只是输入的潜在形式之一。
你可以自由地使用和修改抽象语法树，以实现结构化的模糊处理。
- `可扩展`：作为LibAFL的一部分，我们开发了 `低水平消息传递` ，简称 `LLMP` ，它允许LibAFL在核心上几乎线性扩展。也就是说，如果你选择使用这个功能--毕竟这是你的模糊器。
使用LLMP的 `broker2broker` 功能，通过TCP扩展到多台机器也是可能的。
- `快速`：我们在编译时尽一切努力，使运行时的开销尽可能小。
- `任何目标`：我们支持纯二进制模式，如QEMU-Mode和Frida-Mode与ASAN和CmpLog，以及基于资源的仪器的多个编译通道。
当然，我们也支持自定义插桩，正如你在基于谷歌Atheris的Python例子中看到的那样。
- `可用性`：这个问题由你来决定。尽情发挥吧!
