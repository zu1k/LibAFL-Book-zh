# 简介

模糊器是安全研究人员和开发人员的重要工具。
一系列最先进的工具，如 [AFL++](https://github.com/AFLplusplus/AFLplusplus)、[libFuzzer](https://llvm.org/docs/LibFuzzer.html) 或 [honggfuzz](https://github.com/google/honggfuzz) 都可供用户使用。它们以一种非常有效的方式完成它们的工作，发现成千上万的bug。

然而，从一个高级用户的角度来看，这些工具是有限的，它们的设计并没有把可扩展性作为第一等公民。
通常情况下，模糊器开发者可以选择 Fork 这些现有的工具，或者从头开始创建一个新的模糊器。在这些情况下，研究人员最终得到有大量的模糊器，它们之间互不兼容，其先进的部分进能够被其自己使用。
在这个过程中，需要一遍又一遍的重新发明轮子，而这些过程完全可以被避免。

为了解决这个问题，我们创建了LibAFL，这是一个库，它不只是一个模糊器，而是一个可重复使用的个体模糊器的集合。
LibAFL是用Rust编写的，它可以帮助你开发一个为你的特定需求而定制的模糊器。
无论是一个特定的目标，一个特定的插桩后端，还是一个自定义的突变器，你都可以利用现有的碎片来制作你能想到的最快、最有效的模糊器。

## 为什么使用 LibAFL?

LibAFL为你提供了许多现成的模糊器的优点，同时又是完全可定制的。

目前的一些亮点功能包括:

- **多平台**: LibAFL 几乎可以在任何 Rust编译器 支持的地平台工作，我们已经在 *Windows*、*Android*、*MacOS* 和 *Linux* 上使用，在 *x86_64*、*aarch64* 上使用
- **移植性**: LibAFL 可以在 `no_std` 模式下构建，这意味着它不需要依赖特定的操作系统。通过定义一个分配器和映射页面的方法，你可以把LibAFL注入到其他目标平台，如嵌入式设备、管理程序，甚至可能是WebAssembly
- **适应性**: 鉴于多年来对 *AFLplusplus* 的开发经验和我们对模糊测试的学术背景，我们可以将最近的模糊测试发展趋势融入到LibAFL的设计中，使其面向未来。
举个例子，相对于老式的模糊器， `BytesInput` 只是输入的潜在形式之一，你可以自由地使用和修改抽象语法树，以实现结构化的模糊处理。
- **扩展性**: 作为LibAFL的一部分，我们开发了 `低水平消息传递` ，简称 `LLMP` ，它允许LibAFL在核心上几乎线性扩展。也就是说，如果你选择使用这个功能--毕竟这是你的模糊器。
使用LLMP的 `broker2broker` 功能，通过TCP扩展到多台机器也是可能的
- **快速**: 我们在编译时尽一切努力，使运行时的开销尽可能小
- **任何目标**: 我们支持纯二进制模式，如 **QEMU-Mode**、**Frida-Mode**、**ASAN**、**CmpLog**，以及基于资源的插桩的多个编译通道。当然，我们也支持自定义插桩，正如你在基于谷歌Atheris的Python例子中看到的那样
- **可用性**: 这个问题由你来决定。尽情发挥吧!
